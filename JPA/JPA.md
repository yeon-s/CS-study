# JPA

# JPA란

자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스

자바 진영의 ORM 표준 기술. 애플리케이션과 JDBC 사이에서 동작

JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야한다.

# ORM

객체와 관계형 데이터베이스를 매핑해주는 것.

ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 해결해준다.

패러다임의 불일치 : 참조를 사용해 연관관계를 가지는 객체와 외래키를 사용해 다른 테이블과 연관관계를 가지는 관계형 데이터베이스

객체를 데이터베이스에 저장할때 ORM프레임워크가 적절한 insert sql문을 생성해 데이터베이스에 객체를 저장해준다.

따라서 데이터 중심인 관계형 데이터베이스 사용해도 객체지향 애플리케이션 개발에 집중할 수 있다.

하이버네이트가 가장 많이 사용됨.

# 객체 중심 개발 가능

객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 다른다. 이 패러다임의 차이를 극복하기 위해 개발자가 너무 많은 시간과 코드를 소비한다. 객체지향 애플리케이션답게 정교한 객체 모델링을 할수록 불일치 문제가 더 커진다. 점점 데이터 중심의 모델로 변해간다. JPA는 이러한 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다. 또한 CRUD SQL을 알아서 처리해줘 생산성이 향상된다.

# JPA의 장점

### 생산성

- CRUD SQL을 개발자가 직접 작성하지 않아도 된다.
- Create Table같은 ddl문을 자동으로 생성해준다.
- 이런 기능들을 사용하면 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.

### 유지보수

- SQL을 직접 다루면 엔티티에 필드를 하나만 추가해도 SQL과 JDBC API 코드를 모두 변경해야한다.
- JPA 사용하면 JPA가 대신 처리해주므로 엔티티 필드만 수정해도 된다.

### 패러다임의 불일치 해결

- 상속이나 연관관계 등 관련된 패러다임의 불일치 문제를 해결해줘 데이터 중심 모델이 아닌 객체 중심 모델링을 할 수 있게 해준다.

### 성능

- JPA는 애플리케이션과 데이터베이스 사이에서 동작하는데 영속성 컨텍스트가 엔티티를 관리하면서 1차캐시 기능이 있어서 예를 들어 같은 회원을 두번 조회하는 코드가 있을 때 JDBC API는 SQL을 사용해 데이터베이스와 2번 통신했을 겁니다. 하지만 JPA는 SQL을 한번만 데이터베이스에 전달하고 두번째는 조회한 회원객체를 재사용하므로 성능 부분에서 최적화를 할 수가 있다.

# 마이바티스와 차이점

마이바티스는 객체와 SQL을 매핑하는 SQL 매퍼역할을 하는데 결국 개발자가 SQL을 직접 작성해야하므로 SQL에 의존하는 개발을 하게 된다. 반면 ORM은 객체와 테이블을 매핑만하면 SQL을 만들어주므로 SQL에 의존하는 개발을 피할 수 있습니다.

- SQL 의존적인 개발 피할 수 있다.(SQL 일일이 다 생성해야함, 필드하나만 추가되도 SQL이랑 JDBC API 수정해야함),락 타임 최소화
- 패러다임 불일치 피해서 객체 중심 모델링 가능하다(참조를 통해 연관관계 가지는 객체랑 외래키를 통해 연관관계 가지는 데이터베이스로 패러다임이 다른데 JPA를 사용하면 객체랑 테이블을 매핑해줘서 객체 중심 모델링 가능하다.)
- 영속성 컨텍스트 사용해서 성능 최적화

# 매핑 어노테이션

- @Entity, @Table, @Column 등
- JPA는 매핑 어노테이션을 분석해서 어떤 객체가 어떤 테이블과 관계가 있는지 알아낸다.

# 엔티티 매니저

- 엔티티를 관리하는 관리자
- 엔티티매니저 팩토리에서 엔티티 매니저를 생성한다.
- 엔티티 매니저 팩토리는 엔티티 매니저를 만드는 공장인데 공장을 만드는 비용이크다.
- 따라서 한개만 만들어서 애플리케이션 전체에서 공유한다.
- 반면 공장에서 엔티티 매니저를 생성하는 비용은 거의 안든다.

**엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간 공유하면 안된다.**

# 영속성 컨텍스트

- **엔티티를 영구 저장하는 환경**
- 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다.

# 영속성 컨텍스트의 특징

- 영속성 컨텍스트와 식별자 값
    - 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.
- 영속성 컨텍스트와 데이터베이스 저장
    - JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 플러시라한다.
    - 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업이다.
- 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.
    - 1차 캐시
        - 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 영속 상태의 엔티티는 모두 이곳에 저장된다.
        - find()로 조회하면 먼저 1차캐시에서 엔티티를 찾고 없으면 데이터베이스에서 조회한다.
        - 1차 캐시에 없으면 데이터베이스 조회해서 엔티티 생성하고 1차 캐시에 저장한 후에 엔티티 반환한다.
    - 동일성 보장
    - 트랙잭션을 지원하는 쓰기 지연
        - 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아뒀다가 커밋할 때 모안둔 쿼리를 데이터베이스에 보낸다. 이것을 트랜잭션을 지원하는 쓰기 지연이라 한다.
    - 변경 감지
        - 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능
        - JPA는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라 한다. 그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾고 변경된 엔티티가 있으면 수정 쿼리를 생성해서 내부 쿼리저장소에 보낸다.
        - 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
    - 지연 로딩

# 엔티티 매핑

### @Entity

- 기본 생성자가 필수로 있어야한다.
- 필드에 final 쓰면 안된다.
- 자바는 생성자 하나 이상 만들면 기본생성자를 자동으로 만들어주지 않기 때문에 직접 기본 생성자 만들어야한다.

# 기본 키 매핑

### @GeneratedValue

- identity전략: 데이터를 데이터베이스에 insert한 후에 기본 키 값을 조회할 수 있다.
- 따라서 엔티티에 기본키를 할당하려면 JPA는 추가로 데이터베이스를 조회해야한다.
- 엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다. 그런데 identity 식별자 생성 전략은 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있으므로 em.persist()를 호출하는 즉시 SQL이 데이터베이스에 전달된다. 따라서 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.

# @Access

- JPA가 엔티티 데이터에 접근하는 방식을 지정한다.
- 필드접근: AccessType.FIELD로 지정한다. 필드에 직접 접근한다. 필드접근 권한이 private이어도 접근할 수 있다.
- 프로퍼티 접근: AccessType.PROPERTY로 지정한다. 접근자(Getter)를 사용한다.
- @Access를 생략하면 @Id의 위치를 기준으로 접근방식 설정한다.

# 데이터 중심 설계의 문제점

- 객체지향 설계는 각각의 객체가 맡은 역할과 책임이 있고 관련있는 객체끼리 참조하도록 설계해야한다.
- 관계형 데이터베이스는 연관된 객체를 찾을때 외래키를 사용해서 조인하면 되지만 객체에는 조인이 없기때문에 연관된 객체를 찾을 때 참조를 사용해야 한다.
- 객체는 참조를 사용해서 연관된 객체를 찾고 테이블은 외래키를 사용해서 연관된 테이블을 찾으므로 둘 사이에는 큰 차이가 있다.
- JPA는 객체의 참조와 테이블의 외래키를 매핑해서 객체에서는 참조를 사용하고 테이블에서는 외래 키를 사용할 수 있도록 한다.

# 연관관계 매핑

- 참조를 통한 연관관계는 언제나 단방향이다.
- 테이블은 외래 키 하나로 양방향으로 조인할 수 있다.
- JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.
- 객체는 양방향 연관관계라는 것이 없다. 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐이다.
- **엔티티를 단방향으로 매핑하면 참조를 하나만 사용하므로 이 참조로 외래키를 관리하면된다. 그러나 양방향으로 매핑하면 두곳에서 서로를 참조하므로 객체의 연관관계를 관리하는 포인트는 2곳으로 늘어난다.**
- **엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래키는 하나다. 따라서 둘 사이에 차이가 발생한다.**
- 이런 차이로 인해 JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는데 이것을 연관관계의 주인이라 한다.
- 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래키를 관리(등록, 수정, 삭제)할 수 있다. 반면 주인이 아닌쪽은 읽기만 할 수 있다.
- 어떤 연관관계를 주인으로 정할지는 mappedBy 속성을 사용하면 된다. (주인은 mappedBy 속성을 사용하지 않는다. 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야한다.)
- **연관관계의 주인은 외래키가 있는 곳으로 (외래키가 없는 쪽을 주인으로 하면 물리적으로 전혀 다른 테이블의 외래 키를 관리해야 하므로)**
- 연관관계의 주인만 데이터베이스 연관관계와 매핑되고 외래키를 관리할 수 있다.
- 데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래키를 가진다. 다 쪽인 @ManyToOne은 항상 연관관계의 주인이 되므로 mappedBy를 설정할 수 없어 mappedBy속성이 없다.

# 양방향 연관관계

- 양방향 연관관계를 설정하고 가장 흔히 하는 실수는 연관관계의 주인에는 값을 입력하지 않고 주인이 아닌 곳에만 값을 입력하는 것이다.
- JPA를 사용하면 주인이 아닌 방향은 값을 설정하지 않아도 데이터베이스에 외래 키 값이 정상 입력된다.
- 하지만 객체 관점에서는 양쪽 방향 모두에 값을 입력해주는 것이 안전하다. 따라서 객체까지 고려해서 주인이 아닌 곳에도 값을 입력하자.(양쪽 모두 관계를 맺어주자)
- 단방향 매핑과 비교해서 양방향 매핑은 복잡하다. (연관관계의 주인도 정해야하고 두개의 단방향 연관관계를 양방향으로 만들기 위해 로직도 잘 관리해야한다)
- **단방향과 비교해서 양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것 뿐이다.**
- 사실 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료되었다.
- 양방향 연관관계를 매핑하려면 객체에서 양쪽 모두를 관리해야하므로(복잡하므로) 우선 단방향 매핑을 사용하고 반대방향으로 객체 그래프 탐색 기능이 필요할 때 양방향을 사용하도록 추가하자.

# 프록시, 즉시로딩, 지연로딩, 영속성 전이

### 지연로딩

- 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법(예를들어 외래키로 참조하고 있는 객체는 사용하지 않을때)
- 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라 한다.

### 프록시

- 프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같다.
- 프록시 객체는 실제 객체에 대한 참조를 보관한다. 그리고 프록시 객체의 메소드를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.
- 프록시 객체는 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데 이것을 프록시 객체의 초기화라 한다.
- 프록시 객체는 처음 사용할 때 한번만 초기화된다.
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화 되면 프록시 객체를 통해 실제 엔티티에 접근할 수 있다.(프록시 객체는 실제 엔티티 객체의 참조를 멤버변수에 보관한다.)

### 즉시로딩, 지연로딩

회원1이 팀1에 소속해 있다고 가정해보자

회원 엔티티를 조회할 때 연관된 팀 엔티티도 함께 데이터베이스에서 조회하는 것이 좋을까? 아니면 회원 엔티티만 조회해 두고 팀 엔티티는 실제 사용하는 시점에 데이터베이스에서 조회하는 것이 좋을까?

JPA는 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 두가지 방법을 제공한다.

### **즉시 로딩: 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.**

즉시 로딩을 사용하려면 @ManyToOne의 fetch 속성을 FetchType.EAGER로 설정한다.

대부분의 JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다.

![Untitled](/image/jpa/Untitled.png)

**nullable 설정에 따른 조인 전략**

널 허용: 외부조인 사용

널 허용하지 않음: 내부 조인 사용

외래키를 널 허용하게 되면 내부조인 했을 때 데이터 조회를 못하는 경우가 발생하기 때문

### **지연 로딩: 연관된 엔티티를 실제 사용할 때 조회한다.**

@ManyToOne(fetch=FetchType.LAZY)

연관된 엔티티를 사용하기 전까지는 프록시 객체를 넣어둔다. 이 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룬다. 그래서 지연 로딩이라고 한다.

실제 데이터가 필요한 순간(사용하는 순간)이 되어서야 데이터베이스를 조회해서 프록시 객체를 초기화한다.

**조회 대상이 영속성 컨텍스트에 이미 있으면 프록시 객체를 사용할 이유가 없다. 따라서 프록시가 아닌 실제 객체를 사용한다.** 

**즉시 로딩이 좋은지 지연 로딩이 좋은지는 상황에 따라 다르다.**

![Untitled](/image/jpa/Untitled1.png)

### JPA 기본 페치 전략

@ManyToOne, @OneToOne은 즉시로딩, @OneToMany, @ManyToMany는 지연로딩

JPA 기본 페치 전략은 연관된 엔티티가 하나면 즉시로딩을, 컬렉션이면 지연로딩을 사용한다. 컬렉션을 로딩하는 것은 비용이 많이 들고 잘못하면 너무 많은 데이터를 로딩할 수 있기 때문이다. 반면 연관된 엔티티가 하나면 즉시 로딩해도 큰 문제가 발생하지는 않는다.

**추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것이다.**

### 영속성 전이:CASCADE

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이 기능을 사용하면 된다. JPA는 CASCADE 옵션으로 영속성 전이를 제공한다. 쉽게 말해 영속성 전이를 사용하면 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 수 있다.
- 엔티티를 영속 상태로 만들어서 데이터베이스에 저장할 때 연관된 엔티티도 모두 영속 상태여야 한다. 연관된 엔티티 중에 영속 상태가 아닌 엔티티가 있으면 예외가 발생한다.
- CASCADE 옵션으로 저장, 병합, 삭제 등에서도 영속성 전이가 가능하다.

### 고아 객체

- JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체 제거라 한다. 이 기능을 사용해서 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제된다.
- 고아 객체 제거는 참조가 제거된 엔티티는 다른 곳에서도 참조하지 않는 고아 객체로 보고 삭제하는 기능. 따라서 이 기능은 참조하는 곳이 하나일 때만 사용해야 한다.

# Spring Data JPA

- 스프링 프레임워크에서 JPA를 편리하게 사용할 수 있도록 지원하는 프로젝트이다.
- CRUD를 처리하기 위한 공통 인터페이스를 제공한다.
- 레포지토리를 개발할 때 인터페이스만 작성하면 실행 시점에 스프링 데이터 JPA가 구현 객체를 동적으로 생성해서 주입해준다. 따라서 데이터 접근 계층을 개발할 때 구현 클래스 없이 인터페이스만 작성해도 개발을 완료할 수 있다.
- 직접 작성한 공통으로 처리할 수 없는 메소드는 스프링 데이터 JPA가 메소드 이름을 분석해서 JPQL을 실행한다.

### JpaRepository 인터페이스

- 인터페이스 상속받으면 사용할 수 있는 주요 메소드
- save(S) : 새로운 엔티티는 저장하고 이미 있는 엔티티는 수정한다.
    - 엔티티에 식별자 값이 없으면(null)이면 새로운 엔티티로 판단해서 persist() 호출하고 식별자 값이 있으면 이미 있는 엔티티로 판단해서 merge() 호출한다.
- delete(T) : 엔티티 하나를 삭제한다. 내부에서 EntityManager.remove()를 호출한다.
- findOne(ID): 엔티티 하나를 조회한다. 내부에서 EntityManager.find()를 호출한다.
- getOne(ID) : 엔티티를 프록시로 조회한다. 내부에서 EntityManager.getReference()를 호출한다.
- findAll(): 모든 엔티티를 조회한다. 정렬(sort)나 페이징(Pageable) 조건을 파라미터로 제공할 수 있다.

### 쿼리 메소드 기능

- 메소드 이름만으로 쿼리를 생성하는 기능이 있는데 인터페잇스에 메소드만 선언하면 해당 메소드의 이름으로 적절한 JPQL 쿼리를 생성해서 실행한다.
- 스르핑 데이터 JPA가 제공하는 쿼리 메소드 기능은 3가지가 있다.
    - 메소드 이름으로 쿼리 생성
    - 메소드 이름으로 JPA NamedQuery 호출
    - @Query 어노테이션을 사용해서 레포지토리 인터페이스에 쿼리 직접 정의

### 반환타입

- 스프링 데이터 JPA는 유연한 반환 타입을 지원하는데 결과가 한 건 이상이면 컬렉션 인터페이스를 사용하고 단건이면 반환 타입을 지정한다.

### 페이징과 정렬

- 스프링 데이터 JPA는 쿼리 메소드에 페이징과 정렬 기능을 사용할 수 있도록 2가지 파라미터를 제공한다. (Sort와 Pageable)

### 트랜잭션 범위의 영속성 컨텍스트

스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다. 이 전략은 이름 그대로 트랜잭션의 범위와 영속성 컨텍스트의 생존 범위가 같다는 뜻이다. 스프링 프레임워크를 사용하면 보통 비즈니스 로직을 시작하는 서비스 계층에 @Transactional 어노테이션을 선언해서 트랜잭션을 시작한다. 이 어노테이션이 있으면 호출한 메소드를 실행하기 직전에 스프링의 트랜잭션 AOP가 먼저 동작한다. 

![Untitled](/image/jpa/Untitled2.png)

- 엔티티 매니저는 달라도 같은 트랜잭션 범위에 있으면 같은 영속성 컨텍스트 사용한다.
- 여러 스레드에서 동시에 요청이 와서 같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다. (스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다. ⇒ 따라서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르므로 멀티 쓰레드 상황에 안전하다.)
- 스프링의 장점은 트랜잭션과 복잡한 멀티 스레드 상황을 컨테이너가 처리해준다는 점이다. 따라서 개발자는 싱글 스레드 애플리케이션처럼 단순하게 개발할 수 있고 결과적으로 비즈니스 로직 개발에 집중할 수 있다.

### 준영속 상태와 지연 로딩

# N+1문제

- 처음 실행한 SQL의 결과 수 만큼 추가로 SQL을 실행하는 것.
- 즉시 로딩은 JPQL을 실행할 때 N+1 문제가 발생할 수 있다.
- 지연 로딩은 JPQL에서는 N+1문제가 발생하지 않지만 이후 비즈니스 로직에서 컬렉션을 사용할 때 발생한다.

**해결방법**

- N+1문제를 해결하는 가장 일반적인  방법은 패치 조인을 사용하는 것이다. 페치 조인은 SQL 조인을 사용해서 연관된 엔티티를 함께 조회하므로 N+1문제가 발생하지 않는다.
- @BatchSize 어노테이션 사용해서 연관된 엔티티 조회할 때 지정한 사이즈 만큼 SQL의 IN 절을 사용해서 조회한다.
- @Fetch 어노테이션에 FetchMode를 Subselect로 사용하면 연관된 데이터를 조회할 때 서브 쿼리 사용해서 N+1문제를 해결한다.

**결론 : 즉시로딩 사용하지 말고 지연로딩만 사용하자. 즉시 로딩 전략은 그럴듯해 보이지만 N+1문제는 물론이고 비즈니스 로직에 따라 필요하지 않은 엔티티를 로딩해야하는 상황이 자주 발생한다. 기본 페치 전략이 즉시 로딩인 @OnetoOne 이나 @ManyToOne은 페치타입 lazy로 설정해서 지연 로딩을 사용하자.**

### readonly=true

조회할때는 트랜잭션 시작해도 영속성 컨텍스트 생성안되게 해서 변경감지 같은 무거운 로직이 실행되지 않게 함으로써 성능 최적화 가능

# 락

# JDBC, JPA/Hibernate, Mybatis

### 영속성

- 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성
- 영속성을 갖지 않는 데이터는 메모리에서만 존재하기 때문에 프로그램을 종료하면 모두 잃어버리게 된다. 때문에 관계형 데이터베이스 혹은 객체 데이터베이스를 활용하여 데이터를 영구하게 저장하고 영속성을 부여한다.
- Persistence Layer
    - 프로그램의 아키텍처에서 데이터에 영속성을 부여해주는 계층
    - JDBC를 이용해 직접 구현할 수 있지만 Persistence framework를 이용한 개발이 많이 이루어진다.
- Persistence Framework
    - JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발할 수 있으며 안정적인 구동을 보장한다.
    - SQL Mapper와 ORM으로 나눌 수 있다.
    - EX) JPA, Hibernate, Mybatis
