# JPA

# JPA란

자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스

자바 진영의 ORM 표준 기술. 애플리케이션과 JDBC 사이에서 동작

JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야한다.

# ORM

객체와 관계형 데이터베이스를 매핑해주는 것.

ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 해결해준다.

패러다임의 불일치 : 참조를 사용해 연관관계를 가지는 객체와 외래키를 사용해 다른 테이블과 연관관계를 가지는 관계형 데이터베이스

객체를 데이터베이스에 저장할때 ORM프레임워크가 적절한 insert sql문을 생성해 데이터베이스에 객체를 저장해준다.

따라서 데이터 중심인 관계형 데이터베이스 사용해도 객체지향 애플리케이션 개발에 집중할 수 있다.

하이버네이트가 가장 많이 사용됨.

# 객체 중심 개발 가능

객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 다른다. 이 패러다임의 차이를 극복하기 위해 개발자가 너무 많은 시간과 코드를 소비한다. 객체지향 애플리케이션답게 정교한 객체 모델링을 할수록 불일치 문제가 더 커진다. 점점 데이터 중심의 모델로 변해간다. JPA는 이러한 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다. 또한 CRUD SQL을 알아서 처리해줘 생산성이 향상된다.

# JPA의 장점

### 생산성

- CRUD SQL을 개발자가 직접 작성하지 않아도 된다.
- Create Table같은 ddl문을 자동으로 생성해준다.
- 이런 기능들을 사용하면 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.

### 유지보수

- SQL을 직접 다루면 엔티티에 필드를 하나만 추가해도 SQL과 JDBC API 코드를 모두 변경해야한다.
- JPA 사용하면 JPA가 대신 처리해주므로 엔티티 필드만 수정해도 된다.

### 패러다임의 불일치 해결

- 상속이나 연관관계 등 관련된 패러다임의 불일치 문제를 해결해줘 데이터 중심 모델이 아닌 객체 중심 모델링을 할 수 있게 해준다.

### 성능

- JPA는 애플리케이션과 데이터베이스 사이에서 동작하는데 영속성 컨텍스트가 엔티티를 관리하면서 1차캐시 기능이 있어서 예를 들어 같은 회원을 두번 조회하는 코드가 있을 때 JDBC API는 SQL을 사용해 데이터베이스와 2번 통신했을 겁니다. 하지만 JPA는 SQL을 한번만 데이터베이스에 전달하고 두번째는 조회한 회원객체를 재사용하므로 성능 부분에서 최적화를 할 수가 있다.

# 마이바티스와 차이점

마이바티스는 객체와 SQL을 매핑하는 SQL 매퍼역할을 하는데 결국 개발자가 SQL을 직접 작성해야하므로 SQL에 의존하는 개발을 하게 된다. 반면 ORM은 객체와 테이블을 매핑만하면 SQL을 만들어주므로 SQL에 의존하는 개발을 피할 수 있습니다.

- SQL 의존적인 개발 피할 수 있다.(SQL 일일이 다 생성해야함, 필드하나만 추가되도 SQL이랑 JDBC API 수정해야함),락 타임 최소화
- 패러다임 불일치 피해서 객체 중심 모델링 가능하다(참조를 통해 연관관계 가지는 객체랑 외래키를 통해 연관관계 가지는 데이터베이스로 패러다임이 다른데 JPA를 사용하면 객체랑 테이블을 매핑해줘서 객체 중심 모델링 가능하다.)
- 영속성 컨텍스트 사용해서 성능 최적화

# 매핑 어노테이션

- @Entity, @Table, @Column 등
- JPA는 매핑 어노테이션을 분석해서 어떤 객체가 어떤 테이블과 관계가 있는지 알아낸다.

# 엔티티 매니저

- 엔티티를 관리하는 관리자
- 엔티티매니저 팩토리에서 엔티티 매니저를 생성한다.
- 엔티티 매니저 팩토리는 엔티티 매니저를 만드는 공장인데 공장을 만드는 비용이크다.
- 따라서 한개만 만들어서 애플리케이션 전체에서 공유한다.
- 반면 공장에서 엔티티 매니저를 생성하는 비용은 거의 안든다.

**엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간 공유하면 안된다.**

# 영속성 컨텍스트

- **엔티티를 영구 저장하는 환경**
- 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다.

# 영속성 컨텍스트의 특징

- 영속성 컨텍스트와 식별자 값
    - 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.
- 영속성 컨텍스트와 데이터베이스 저장
    - JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 플러시라한다.
    - 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업이다.
- 영속성 컨텍스트가 엔티티를 관리하면 다음과 같은 장점이 있다.
    - 1차 캐시
        - 영속성 컨텍스트는 내부에 캐시를 가지고 있는데 영속 상태의 엔티티는 모두 이곳에 저장된다.
        - find()로 조회하면 먼저 1차캐시에서 엔티티를 찾고 없으면 데이터베이스에서 조회한다.
        - 1차 캐시에 없으면 데이터베이스 조회해서 엔티티 생성하고 1차 캐시에 저장한 후에 엔티티 반환한다.
    - 동일성 보장
    - 트랙잭션을 지원하는 쓰기 지연
        - 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아뒀다가 커밋할 때 모안둔 쿼리를 데이터베이스에 보낸다. 이것을 트랜잭션을 지원하는 쓰기 지연이라 한다.
    - 변경 감지
        - 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능
        - JPA는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라 한다. 그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾고 변경된 엔티티가 있으면 수정 쿼리를 생성해서 내부 쿼리저장소에 보낸다.
        - 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
    - 지연 로딩

# 엔티티 매핑

### @Entity

- 기본 생성자가 필수로 있어야한다.
- 필드에 final 쓰면 안된다.
- 자바는 생성자 하나 이상 만들면 기본생성자를 자동으로 만들어주지 않기 때문에 직접 기본 생성자 만들어야한다.

# 기본 키 매핑

### @GeneratedValue

- identity전략: 데이터를 데이터베이스에 insert한 후에 기본 키 값을 조회할 수 있다.
- 따라서 엔티티에 기본키를 할당하려면 JPA는 추가로 데이터베이스를 조회해야한다.
- 엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다. 그런데 identity 식별자 생성 전략은 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있으므로 em.persist()를 호출하는 즉시 SQL이 데이터베이스에 전달된다. 따라서 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.

# @Access

- JPA가 엔티티 데이터에 접근하는 방식을 지정한다.
- 필드접근: AccessType.FIELD로 지정한다. 필드에 직접 접근한다. 필드접근 권한이 private이어도 접근할 수 있다.
- 프로퍼티 접근: AccessType.PROPERTY로 지정한다. 접근자(Getter)를 사용한다.
- @Access를 생략하면 @Id의 위치를 기준으로 접근방식 설정한다.

# 데이터 중심 설계의 문제점

- 객체지향 설계는 각각의 객체가 맡은 역할과 책임이 있고 관련있는 객체끼리 참조하도록 설계해야한다.
- 관계형 데이터베이스는 연관된 객체를 찾을때 외래키를 사용해서 조인하면 되지만 객체에는 조인이 없기때문에 연관된 객체를 찾을 때 참조를 사용해야 한다.
- 객체는 참조를 사용해서 연관된 객체를 찾고 테이블은 외래키를 사용해서 연관된 테이블을 찾으므로 둘 사이에는 큰 차이가 있다.
- JPA는 객체의 참조와 테이블의 외래키를 매핑해서 객체에서는 참조를 사용하고 테이블에서는 외래 키를 사용할 수 있도록 한다.

# 연관관계 매핑

- 참조를 통한 연관관계는 언제나 단방향이다.
- 테이블은 외래 키 하나로 양방향으로 조인할 수 있다.
- JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.
- 객체는 양방향 연관관계라는 것이 없다. 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐이다.
- **엔티티를 단방향으로 매핑하면 참조를 하나만 사용하므로 이 참조로 외래키를 관리하면된다. 그러나 양방향으로 매핑하면 두곳에서 서로를 참조하므로 객체의 연관관계를 관리하는 포인트는 2곳으로 늘어난다.**
- **엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래키는 하나다. 따라서 둘 사이에 차이가 발생한다.**
- 이런 차이로 인해 JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는데 이것을 연관관계의 주인이라 한다.
- 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래키를 관리(등록, 수정, 삭제)할 수 있다. 반면 주인이 아닌쪽은 읽기만 할 수 있다.
- 어떤 연관관계를 주인으로 정할지는 mappedBy 속성을 사용하면 된다. (주인은 mappedBy 속성을 사용하지 않는다. 주인이 아니면 mappedBy 속성을 사용해서 속성의 값으로 연관관계의 주인을 지정해야한다.)
- **연관관계의 주인은 외래키가 있는 곳으로 (외래키가 없는 쪽을 주인으로 하면 물리적으로 전혀 다른 테이블의 외래 키를 관리해야 하므로)**
- 연관관계의 주인만 데이터베이스 연관관계와 매핑되고 외래키를 관리할 수 있다.
- 데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래키를 가진다. 다 쪽인 @ManyToOne은 항상 연관관계의 주인이 되므로 mappedBy를 설정할 수 없어 mappedBy속성이 없다.

# 양방향 연관관계

- 양방향 연관관계를 설정하고 가장 흔히 하는 실수는 연관관계의 주인에는 값을 입력하지 않고 주인이 아닌 곳에만 값을 입력하는 것이다.
- JPA를 사용하면 주인이 아닌 방향은 값을 설정하지 않아도 데이터베이스에 외래 키 값이 정상 입력된다.
- 하지만 객체 관점에서는 양쪽 방향 모두에 값을 입력해주는 것이 안전하다. 따라서 객체까지 고려해서 주인이 아닌 곳에도 값을 입력하자.(양쪽 모두 관계를 맺어주자)
- 단방향 매핑과 비교해서 양방향 매핑은 복잡하다. (연관관계의 주인도 정해야하고 두개의 단방향 연관관계를 양방향으로 만들기 위해 로직도 잘 관리해야한다)
- **단방향과 비교해서 양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것 뿐이다.**
- 사실 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료되었다.
- 양방향 연관관계를 매핑하려면 객체에서 양쪽 모두를 관리해야하므로(복잡하므로) 우선 단방향 매핑을 사용하고 반대방향으로 객체 그래프 탐색 기능이 필요할 때 양방향을 사용하도록 추가하자.

# 프록시, 즉시로딩, 지연로딩, 영속성 전이

### 지연로딩

- 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법(예를들어 외래키로 참조하고 있는 객체는 사용하지 않을때)
- 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라 한다.

### 프록시

- 프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같다.
- 프록시 객체는 실제 객체에 대한 참조를 보관한다. 그리고 프록시 객체의 메소드를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.
- 프록시 객체는 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데 이것을 프록시 객체의 초기화라 한다.
- 프록시 객체는 처음 사용할 때 한번만 초기화된다.
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화 되면 프록시 객체를 통해 실제 엔티티에 접근할 수 있다.(프록시 객체는 실제 엔티티 객체의 참조를 멤버변수에 보관한다.)

### 즉시로딩, 지연로딩

회원1이 팀1에 소속해 있다고 가정해보자

회원 엔티티를 조회할 때 연관된 팀 엔티티도 함께 데이터베이스에서 조회하는 것이 좋을까? 아니면 회원 엔티티만 조회해 두고 팀 엔티티는 실제 사용하는 시점에 데이터베이스에서 조회하는 것이 좋을까?

JPA는 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 두가지 방법을 제공한다.

### **즉시 로딩: 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.**

즉시 로딩을 사용하려면 @ManyToOne의 fetch 속성을 FetchType.EAGER로 설정한다.

대부분의 JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다.

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled.png)

**nullable 설정에 따른 조인 전략**

널 허용: 외부조인 사용

널 허용하지 않음: 내부 조인 사용

외래키를 널 허용하게 되면 내부조인 했을 때 데이터 조회를 못하는 경우가 발생하기 때문

### **지연 로딩: 연관된 엔티티를 실제 사용할 때 조회한다.**

@ManyToOne(fetch=FetchType.LAZY)

연관된 엔티티를 사용하기 전까지는 프록시 객체를 넣어둔다. 이 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룬다. 그래서 지연 로딩이라고 한다.

실제 데이터가 필요한 순간(사용하는 순간)이 되어서야 데이터베이스를 조회해서 프록시 객체를 초기화한다.

**조회 대상이 영속성 컨텍스트에 이미 있으면 프록시 객체를 사용할 이유가 없다. 따라서 프록시가 아닌 실제 객체를 사용한다.** 

**즉시 로딩이 좋은지 지연 로딩이 좋은지는 상황에 따라 다르다.**

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%201.png)

### JPA 기본 페치 전략

@ManyToOne, @OneToOne은 즉시로딩, @OneToMany, @ManyToMany는 지연로딩

JPA 기본 페치 전략은 연관된 엔티티가 하나면 즉시로딩을, 컬렉션이면 지연로딩을 사용한다. 컬렉션을 로딩하는 것은 비용이 많이 들고 잘못하면 너무 많은 데이터를 로딩할 수 있기 때문이다. 반면 연관된 엔티티가 하나면 즉시 로딩해도 큰 문제가 발생하지는 않는다.

**추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것이다.**

### 영속성 전이:CASCADE

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이 기능을 사용하면 된다. JPA는 CASCADE 옵션으로 영속성 전이를 제공한다. 쉽게 말해 영속성 전이를 사용하면 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 수 있다.
- 엔티티를 영속 상태로 만들어서 데이터베이스에 저장할 때 연관된 엔티티도 모두 영속 상태여야 한다. 연관된 엔티티 중에 영속 상태가 아닌 엔티티가 있으면 예외가 발생한다.
- CASCADE 옵션으로 저장, 병합, 삭제 등에서도 영속성 전이가 가능하다.

### 고아 객체

- JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체 제거라 한다. 이 기능을 사용해서 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제된다.
- 고아 객체 제거는 참조가 제거된 엔티티는 다른 곳에서도 참조하지 않는 고아 객체로 보고 삭제하는 기능. 따라서 이 기능은 참조하는 곳이 하나일 때만 사용해야 한다.

# Spring Data JPA

- 스프링 프레임워크에서 JPA를 편리하게 사용할 수 있도록 지원하는 프로젝트이다.
- CRUD를 처리하기 위한 공통 인터페이스를 제공한다.
- 레포지토리를 개발할 때 인터페이스만 작성하면 실행 시점에 스프링 데이터 JPA가 구현 객체를 동적으로 생성해서 주입해준다. 따라서 데이터 접근 계층을 개발할 때 구현 클래스 없이 인터페이스만 작성해도 개발을 완료할 수 있다.
- 직접 작성한 공통으로 처리할 수 없는 메소드는 스프링 데이터 JPA가 메소드 이름을 분석해서 JPQL을 실행한다.

### JpaRepository 인터페이스

- 인터페이스 상속받으면 사용할 수 있는 주요 메소드
- save(S) : 새로운 엔티티는 저장하고 이미 있는 엔티티는 수정한다.
    - 엔티티에 식별자 값이 없으면(null)이면 새로운 엔티티로 판단해서 persist() 호출하고 식별자 값이 있으면 이미 있는 엔티티로 판단해서 merge() 호출한다.
- delete(T) : 엔티티 하나를 삭제한다. 내부에서 EntityManager.remove()를 호출한다.
- findOne(ID): 엔티티 하나를 조회한다. 내부에서 EntityManager.find()를 호출한다.
- getOne(ID) : 엔티티를 프록시로 조회한다. 내부에서 EntityManager.getReference()를 호출한다.
- findAll(): 모든 엔티티를 조회한다. 정렬(sort)나 페이징(Pageable) 조건을 파라미터로 제공할 수 있다.

### 쿼리 메소드 기능

- 메소드 이름만으로 쿼리를 생성하는 기능이 있는데 인터페잇스에 메소드만 선언하면 해당 메소드의 이름으로 적절한 JPQL 쿼리를 생성해서 실행한다.
- 스르핑 데이터 JPA가 제공하는 쿼리 메소드 기능은 3가지가 있다.
    - 메소드 이름으로 쿼리 생성
    - 메소드 이름으로 JPA NamedQuery 호출
    - @Query 어노테이션을 사용해서 레포지토리 인터페이스에 쿼리 직접 정의

### 반환타입

- 스프링 데이터 JPA는 유연한 반환 타입을 지원하는데 결과가 한 건 이상이면 컬렉션 인터페이스를 사용하고 단건이면 반환 타입을 지정한다.

### 페이징과 정렬

- 스프링 데이터 JPA는 쿼리 메소드에 페이징과 정렬 기능을 사용할 수 있도록 2가지 파라미터를 제공한다. (Sort와 Pageable)

### 트랜잭션 범위의 영속성 컨텍스트

스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다. 이 전략은 이름 그대로 트랜잭션의 범위와 영속성 컨텍스트의 생존 범위가 같다는 뜻이다. 스프링 프레임워크를 사용하면 보통 비즈니스 로직을 시작하는 서비스 계층에 @Transactional 어노테이션을 선언해서 트랜잭션을 시작한다. 이 어노테이션이 있으면 호출한 메소드를 실행하기 직전에 스프링의 트랜잭션 AOP가 먼저 동작한다. 

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%202.png)

- 엔티티 매니저는 달라도 같은 트랜잭션 범위에 있으면 같은 영속성 컨텍스트 사용한다.
- 여러 스레드에서 동시에 요청이 와서 같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다. (스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다. ⇒ 따라서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르므로 멀티 쓰레드 상황에 안전하다.)
- 스프링의 장점은 트랜잭션과 복잡한 멀티 스레드 상황을 컨테이너가 처리해준다는 점이다. 따라서 개발자는 싱글 스레드 애플리케이션처럼 단순하게 개발할 수 있고 결과적으로 비즈니스 로직 개발에 집중할 수 있다.

### 준영속 상태와 지연 로딩

# N+1문제

- 처음 실행한 SQL의 결과 수 만큼 추가로 SQL을 실행하는 것.
- 즉시 로딩은 JPQL을 실행할 때 N+1 문제가 발생할 수 있다.
- 지연 로딩은 JPQL에서는 N+1문제가 발생하지 않지만 이후 비즈니스 로직에서 컬렉션을 사용할 때 발생한다.

**해결방법**

- N+1문제를 해결하는 가장 일반적인  방법은 패치 조인을 사용하는 것이다. 페치 조인은 SQL 조인을 사용해서 연관된 엔티티를 함께 조회하므로 N+1문제가 발생하지 않는다.
- @BatchSize 어노테이션 사용해서 연관된 엔티티 조회할 때 지정한 사이즈 만큼 SQL의 IN 절을 사용해서 조회한다.
- @Fetch 어노테이션에 FetchMode를 Subselect로 사용하면 연관된 데이터를 조회할 때 서브 쿼리 사용해서 N+1문제를 해결한다.

**결론 : 즉시로딩 사용하지 말고 지연로딩만 사용하자. 즉시 로딩 전략은 그럴듯해 보이지만 N+1문제는 물론이고 비즈니스 로직에 따라 필요하지 않은 엔티티를 로딩해야하는 상황이 자주 발생한다. 기본 페치 전략이 즉시 로딩인 @OnetoOne 이나 @ManyToOne은 페치타입 lazy로 설정해서 지연 로딩을 사용하자.**

### readonly=true

조회할때는 트랜잭션 시작해도 영속성 컨텍스트 생성안되게 해서 변경감지 같은 무거운 로직이 실행되지 않게 함으로써 성능 최적화 가능

# 동시성 문제

동시성 문제란 두 개 이상의 세션이 공통된 자원에 대해 모두 읽고 쓰는 작업을 하려고 하는 경우 발생할 수 있는 문제를 말한다. 애플리케이션을 개발하다보면 여러 동시성 문제들을 만나고, 동시성 제어를 도와주는 여러 시스템들(데이터베이스 시스템, JPA 시스템 등)을 보게 된다. 여러 시스템들이 제공하는 상세한 기능들은 모두 상이하지만, 동시성 문제를 정의하는 방식과 ㅇ제어하는 이론적인 기틀은 모두 동일하다. 

특정 시스템에 종속되지 않는 동시성 문제와 제어 방법론에 대해 정리해보자.

**동시성 문제에 완전한 해결은 없다. 제어(적절한 해결)만 있을 뿐이다. 동시성 문제는 ‘정확성과 동시성을 어떻게 하면 모두 최대로 할 수 있을까?’에 대한 고민이기 때문이다. 동시성(빠르게)을 포기하면 정확성을 높이고, 정확성(얼마나 올바른 데이터)을 타협하면 동시성을 높일 수 있다.**

## 동시성 문제의 2가지 현상

### 일관성 없는 읽기

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%203.png)

세션 2는 동시에 실행되고 있는 세션 1 때문에, 데이터에 접근하는 시점마다 다른 값을 읽게된다. 이를 일관성 없는 읽기라고 한다.

⇒ 일관성 없는 읽기는 해결이 쉽다. 바로 ‘불변성’, 복사본을 이용하면 된다. 세션 2가 최초로 데이터를 조회할 때 해당 데이터를 복사한 후, 이후에도 계속 사용하면 된다. 비록 세션 1이 변경한 데이터의 원장은 감지하지 못하더라도 세션 2 내에서는 계속 동일한 복사본을 바라볼 수 있다.

### 손실되는 업데이트

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%204.png)

더 늦게 시작한 세션 2에 의해 세션 1의 변경사항이 무시되는 현상.

데이터베이스 시스템, JPA 시스템 혹은 우리가 직접 조성해야하는 비즈니스 시스템에서 모두 중요하게 고려되어야 하는 문제이다. 손실되는 업데이트를 방지하기 위한 방법으로는 크게 2가지가 있다. 낙관전 락과 비관적 락이다.

### 낙관적 락

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%205.png)

낙관적 락은 ‘저장 시 체크한다’ 이다. 세션 1이 데이터 A를 읽어왔더라도 세션 2는 자유롭게 데이터 A를 읽을 수 있다. 다만 저장하려고 할때, 저장하려는 대상 데이터가 세션2가 들고있던 데이터와 상이하면 저장이 되지 않는다.

낙관적 락을 구현하기 위해서는 공통된 리소스 A에 대한 Versioning이 되어야한다. 세션2가 들고있는 A의 Version이 저장하려는 대상 A의 Version과 같은지 체크해야하기 때문이다.

### 비관적 락

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%206.png)

비관적 락은 ‘이미 읽고 있는 사람이 있다면 나는 못읽어’이다. 보수적인 잠금이라고 할 수 있다. 낙관적 락에 비해 비관적 락은 세션이 실패할 확률은 줄여주지만 동시성은 떨어진다.

## 데이터베이스와 JPA의 동시성 문제 제어

### 데이터베이스의 동시성 제어

데이터베이스 시스템에서 세션은 ‘트랜잭션’이다. 트랜잭션의 특성 4자기 ACID 중 Isolation은 트랜잭션의 동시성 제어와 깊이 관련이 있다. Isolation의 정도를 나타내는 격리 수준 4가지가 데이터베이스 동시성 제어의 핵심이다. 

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%207.png)

### JPA의 동시성 제어

JPA 시스템에서 세션은 하나의 JPA 트랜잭션이다. JPA에서의 읽기,쓰기 동시성은 Entity객체와 관련이 있다. Entity 객체를 한번 조회하면 JPA의 영속성 컨텍스트에 캐시되기 때문에 세션내에서의 ‘일관성 없는 읽기’의 문제는 없다. (Repeatable Read 수준) 그렇다면 ‘손실되는 업데이트’ 문제를 어떻게 제어할까? JPA는 Entity 단위의 낙관적 락과 비관적 락을 제공한다.

**JPA 낙관적 락**

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%208.png)

JPA의 버전 관리 기능( @Version)을 이용해 Entity의 버전을 관리해 낙관적 락을 구현한다. 애플리케이션 레벨에서의 잠금이며, 낙관적 락이므로 두번째 세션이 Write하기 전까지는 충돌을 알 수 없다. 동시성을 높일 수 있지만, 잘 진행되고 있던 프로세스가 변경 사항을 저장하려고 할 때가지 프로세스의 성패를 예측할 수 없다는 것이 단점이다.

**JPA 비관적 락**

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%209.png)

데이터베이스가 제공하는 락 기능을 이용해 엔티티를 영속 상태로 올릴 때부터 다른 세션에서 조회하지 못하도록 락을 건다. (select for update 구문) 동시성은 저하되지만 정확성과 세션의 성공은 보장된다.

## 쇼핑몰 시스템에서의 주문과 재고 차감

고객의 주문을 처리하는 과정을 도식화하면 

1. 재고가 남았는지 확인
2. 가격을 계산하고 → 주문서를 작성하고 → 결제를 요청
3. 재고 차감

이 때, 하나의 상품에 동시에 여러 주문이 들어올 때 발생할 수 있는 동시성 문제는 ‘손실되는 업데이트’이다. 

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2010.png)

고객이 주문을 한 시점에서 재고가 2개였지만, 주문을 처리하는 과정 중 먼저 누군가 2개를 모두 주문해가면서 재고를 2개 차감했다. 따라서 재고는 0이 되었다. 하지만 현재 이 고객의 주문 세션에서는 주문이 모두 끝난뒤 재고를 2에서 1로 업데이트 하기 때문에, 손실되는 업데이트가 발생하게 된다. 재고는 더이상 믿을 수 없는 값이 되었다.

### 낙관적 락을 통한 해결

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2011.png)

낙관적 락을 이용해 아키텍처를 구성하면 믿을 수 없는 재고값 문제를 해결할 수 있다. 하지만 전체 프로세스 중 트랜잭션의 원자성을 보장하지 못하게 하는 외부 시스템 연동 같은 과정이 있다면 낙관적 락은 사용하기 어렵다. 낙관적 락은 전체 프로세스의 실패를 마지막 저장 시도 시점에 알 수 있는데, 원자적으로 롤백이 어려운 프로세스라면 전체 시스템의 정합성이 깨지기 때문이다.

(마지막에 재고 차감에서 충돌이 일어나 주문은 실패했는데, 외부 결제 시스템 호출은 이미 일어나서 고객의 돈이 빠져나간다면 시스템의 큰 문제일 것이다.)

이런 경우, 시스템의 동시성을 조금 포기하더라도 정확성을 높일 수 있는 비관적 락을 사용할 수 있다.

### 비관적 락을 통한 해결

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2012.png)

비즈니스 애플리케이션의 비관적 락은 보통 동일한 작업을 하는 프로세스들 중 단 하나만이 점유할 수 있는 리소스 (락 혹은 세마포어)를 이용해 구현한다. 한 프로세스가 재고 차감에 대한 락을 점유하고 있다면 현재 주문하려는 고객은 그 락 점유가 해제될 때까지 기다렸다가 프로세스를 실행한다. 모든 주문 프로세스가 순차적으로 진행되는 것이다.

비관적 락은 낙관 락에 비해 동시성은 줄어들어 주문이 몰리는 시점에 고객은 더 느린 주문을 경험하겠지만, 결제만 되고 취소가 되는 부정확한 시스템을 경험하게 될 확률은 줄 것이다.

[http://jaynewho.com/post/42](http://jaynewho.com/post/42)

[http://jaynewho.com/post/43](http://jaynewho.com/post/43)

[http://jaynewho.com/post/44](http://jaynewho.com/post/44)

# 락

## 락의 종류

### 낙관적 락

현실적으로 데이터 갱신시 경합이 발생하지 않을 것이라고 낙관적으로 보고 락을 거는 기법이다. 예를 들어 회원정보에 대한 갱신은 보통 해당 회원에 의해서 이루어지므로 동시에 여러 요청이 발생할 가능성이 낮다. 따라서 동시에 수정이 이루어진 경우를 감지해서 예외를 발생시켜도 실제로 예외가 발생할 가능성이 낮다고 낙관적으로 보는 것이다. 이는 엄밀한 의미에서 보면 잠금이라기 보다는 일종의 충돌감지에 가깝다.

### 비관적 락

동일한 데이터를 동시에 수정할 가능성이 높다는 비관적인 전제로 락을 거는 방식이다. 예를들어 상품의 재고는 동시에 같은 상품을 여러명이 주문할 수 있으므로 데이터 수정에 의한 경합이 발생할 가능성이 높다고 비관적으로 보는 것이다. 이 경우 충돌감지를 통해서 잠금을 발생시키면 충돌발생에 의한 예외가 자주 발생하게 된다. 이럴 경우 비관적 락을 통해 예외를 발생시키지 않고 정합성을 보장하는 것이 가능하다. 다만 성능적인 측면은 손실을 감수해야 한다. 주로 데이터베이스에서 제공하는 배타락을 사용한다.

### 암시적 잠금

암시적 잠금은 프로그램 코드상에 명시적으로 지정하지 않아도 락이 발생하는 것을 의미한다. JPA에서는 엔티티에 @Version이 붙은 필드가 존재하거나 @OptimisticLocking 어노테이션이 설정되어 있을 경우 자동적으로 충돌감지를 위한 락이 실행된다. 그리고 데이터베이스의 경우에는 일반적으로 사용하는 대부분의 데이터베이스가 update,delete 쿼리 발행시에 암시적으로 해당 로우에 대한 행 배타락이 실행된다. JPA의 충돌감지가 역할을 할 수 있는 것도 이와 같은 데이터베이스의 암시적 잠금이 존재하기 때문이다. 데이터베이스의 암시적 잠금이 없다면 충돌감지를 통과한 후 커밋이 실행되는 사이에 틈이 생기므로 충돌감지를 하더라도 정합성을 보증할 수 없을 것이다.

### 명시적 잠금

프로그램을 통해 의도적으로 잠금을 실행하는 것이 명시적 잠금이다. JPA에서 엔티티를 조회할 때 LockMode를 지정하거나 select for update 쿼리를 통해서 직접 락을 지정할 수 있다. 

## 낙관적 락 사용법

JPA에서 낙관적 락을 사용하는 방법.

### @Version

JPA에서 낙관적 락을 사용하기 위해서는 @Version어노테이션을 붙인 필드를 추가하면 간단하게 적용할 수 있다. 특정 필드에 @Version이 붙은 필드를 추가하면 자동적으로 낙관적 락이 적용된다.

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2013.png)

실제로 쿼리를 실행해보면 아래와 같이 업데이트 쿼리 발행시에 조건절에 버전정보가 설정된 것을 볼 수 있다. 현재 엔티티가 가지고 있는 버전정보가 조건절에 적용되며  update문에는 +1된 값이 적용된다. 다른 트랜잭션에 의해서 이미 버전정보가 바뀐상태라고 하면 업데이트 row수가 0이 반환되면서 충돌감지가 되어 예외(OptimisticLockException)가 발생하게 된다. 일단 update문이 실행되면 위에서 언급한 암시적 잠금이 실행되며 동시에 실행된 동일한 엔티티에 대한 쿼리는 앞선 update쿼리가 커밋될때까지 대기하게 되어 정합성을 확실하게 보증할 수 있습니다. 

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2014.png)

### @OptimisticLocking

JPA 표준 스펙에 정의되어 있는 방법이 아니어서 자주 사용되지는 않지만 Hibernate에서 제공하는 낙관적 락을 설정하는 방법이다. 

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2015.png)

Dirty와 All은 버전필드 없이도 낙관적 락을 사용할 수 있는 방법이다.

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2016.png)

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2017.png)

위의 @Version 필드에 의한 잠금과는 다르게 조건절에 전체 컬럼이 걸려있는 것을 볼 수 있다. 조건절에는 업데이트 전의 값이 바인딩 되어있다. 이와 같이 컬럼 전체에 대한 업데이트 여부를 확인함으로써 버전 없는 낙관적 락이 가능하다. 주의할 점은 All을 사용할 경우에는 @DynamicUpdate 어노테이션도 같이 사용해야한다. 이는 필드단위로 Dirty여부를 확인하기 위함이다.

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2018.png)

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2019.png)

Dirty로 지정했을 경우에는 위와 같이 갱신될 컬럼의 갱신 전 값으로 조건절에 바인딩 된다. 특정한 컬럼만 충돌확인에 사용하므로 All이나 @Version을 사용했을 때에 비해 충돌 가능성을 낮출수 있다. 특정 엔티티의 서로 다른 부분을 업데이트하는 프로그램이 있을 경우 충돌하지 않고 수행이 가능하다. @DynamicUpdate를 사용하지 않으면 org.hibernate.MappingException: optimistic-lock=all/dirty requires dynamic-update=”true”와 같은 예외가 발생한다.

## 명시적 낙관적 락

프로그램에 의해 명시적으로 낙관적 락을 사용할 수 있다.

```java
public class SomeService {
    @Transactional
    public void someOperation() {
        Member member = this.entityManager.find(Member.class, memberNo, LockModeType.OPTIMISTIC);
        //do something
    }
}
```

```java
public class SomeService {
    @Transactional
    public void someOperation() {
        Member member = this.entityManager.find(Member.class, memberNo);
        //do something
        this.entityManager.lock(member, LockModeType.OPTIMISTIC);
    }
}
```

위와 같이 엔티티 매니저가 제공하는 EntityManager#find(Class<T> entityClass, Object primaryKey, LockModeType lockMode)나 EntityManager#lock(Object entity, LockModeType lockMode)사용할 수 있다. 

find를 사용하는 경우에는 엔티티를 영속성 컨텍스트로부터 찾거나 없을 경우 select하면서 동시에 락을 걸때 사용하고 lock은 이미 영속성 컨텍스트에 담겨있는 엔티티를 대상으로 락을 걸때 사용한다.

### Optimistic

잠금모드를 Optimistic으로 지정해서 락을 사용하는 경우에는 버전필드의 갱신여부와 상관없이 커밋 직전에 버전을 확인하는 쿼리를 한번 더 발행한다. 

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2020.png)

해당 엔티티에 변경사항이 있을 경우에는 update쿼리에 의해서 이미 충돌감지가 작동하므로 사실상 불필요한 쿼리가 발행될 수 있다. 다만 엔티티에 변경 없이 해당 엔티티에 대한 처리를 수행할 경우에 사용할 수 있다. 엔티티에 대한 변경이 없어 암시적인 배타락이 발생하지 않으므로 완벽한 락이라고 보기 힘든 측면이 있다. 자식 엔티티에 대한 수정을 목적으로 락을 사용하는 경우에는 빈틈이 있으므로 사용하면 안된다. 그럴 경우에는 자식 엔티티의 수정시에 변경할 필드를 추가하거나(예를 들면 자식 엔티티 수정일자 등) 아래의 Optimistic_Force_Increment 잠금모드를 사용해야한다. 

### Optimistic_Force_Increment

Optimistic과 달리 버전을 강제로 증가시키는 잠금이다. 커밋 직전에 아래처럼 버전만 증가시키는 쿼리가 항상 발행된다. 따라서 해당 엔티티에 변경이 있었을 경우에는 변경사항에 대한 업데이트문과 버전을 증가시키는 업데이트문에 의해 버전이 두번 증가한다. Optimistic과 동일하게 엔티티 자체에 변경사항이 있을 경우에는 불필요하게 업데이트 문이 발행되므로 주의할 필요가 있다. 그리고 암시적인 row 배타락이 발생되어 정합성을 보증할 수는 있으므로 자식 엔티티를 수정할 때 자식 엔티티 전체에 대한 잠금용도로 사용할 수 있다. 

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2021.png)

## 비관적 락

### Pessimistic_Read

데이터베이스에서 제공하는 공유락(여러 트랜잭션에서 동시에 읽을 수 있지만 수정할 수 없는 잠금)을 이용해 락을 획득한다. 다만 공유락을 제공하지 않는 경우 Pessimistic_Write와 동일하게 동작한다. 사용하는 데이터베이스에 따라 지원여부가 갈리므로 확인 후 사용해야한다.

```java
public class SomeService {
    @Transactional
    public void someOperation() {
        Member member = this.entityManager.find(Member.class, memberNo, LockModeType.PESSIMISTIC_READ);
        //do something
    }
}
```

### Pessimistic_Write

데이터베이스에서 제공하는 row 배타락을 이용해 잠금을 획득한다. 

```java
public class SomeService {
    @Transactional
    public void someOperation() {
        Member member = this.entityManager.find(Member.class, memberNo, LockModeType.PESSIMISTIC_WRITE);
    }
}
```

### Pessimistic_Force_Increment

데이터베이스에서 제공하는 row 배타락을 이용한 잠금과 동시에 버전을 증가시킨다. 해당하는 엔티티에 변경은 없으나 하위 엔티티를 갱신하기 위해 잠금이 필요한 경우 사용할 수 있다.

```java
public class SomeService {
    @Transactional
    public void someOperation() {
        Member member = this.entityManager.find(Member.class, memberNo, LockModeType.PESSIMISTIC_FORCE_INCREMENT);
    }
}
```

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2022.png)

## 주의사항

### 격리수준

일반적으로 주로 사용되는 데이터베이스는 주로 Read_Committed에 해당하는 격리수준을 가지는 경우가 많다. 하지만 JPA를 사용할 경우 한번 영속성 컨텍스트에 적재된 엔티티를 다시 조회할 경우 데이터베이스를 조회하지 않고 영속성 컨텍스트에서 엔티티를 가져오므로 Repeatable_Read 격리수준과 동일하게 동작한다.

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2023.png)

위 예제는 동일한 엔티티를 두번 조회하면서 두번째 조회시에 비관적 락을 사용하고 있다. 실행 결과는 아래와 같다.

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2024.png)

버전 필드가 존재하지 않는 엔티티의 경우 위와 같이 첫번째 조회시에 영속성 컨텍스트에 적재된 엔티티의 상태는 바뀌지 않고 단순히 select ~for update에 의한 row 배타락이 실행된다. 즉 Repeatable_Read 격리 수준과 동일하게 동작하므로 처음 엔티티가 조회되어 잠금이 실행되기 전에 다른 트랜잭션에 의해서 엔티티가 변경되어 커밋된 상태가 반영되지 않고 현재 트랜잭션의 엔티티 상태가 유지된다는 점을 주의해야 한다. 이럴 경우 앞선 트랜잭션에 의해 변경된 값을 잃어버리는 문제가 발생할 수 있다.

즉, 잠금은 동작했지만 정합성에 문제가 생길 수 있다. 예를 들어 포인트를 사용하는 경우 앞선 트랜잭션에서 차감된 포인트가 반영되지 않음으로써 이중 사용 문제가 발생할 수 있다. 영속성 컨텍스트에 엔티티가 존재하는 것이 확실한 경우에는 EntityManager#refresh나 JPQL을 이용해 데이터베이스로부터 엔티티를 조회하도록 강제할 필요가 있다.

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2025.png)

버전 필드가 존재하는 엔티티의 경우 배타락을 실행하는 조건에 버전정보가 포함되게 된다. 이에 따라 쿼리 실행 후 배타락을 획득하기 전에 다른 트랜잭션에 의해서 버전이 증가하게 되어 잠금 획득에 실패하게 된다. 따라서 비관적 락을 이용하여 순차적인 처리를 기대한 경우라면 기대대로 동작하지 않으므로 주의해야 한다. 

### 쿼리 직접 사용

@Version 필드가 존재하는 엔티티에 JPQL이나 네이티브 쿼리를 사용하는 경우 주의할 필요가 있다. JPQL이나 네이티브 쿼리 실행 시 버전정보를 증가시키는 것을 누락할 경우 낙관적 락에 빈틈이 생길 수 있으므로 주의해야하낟.

### Timeout

비관적 락에 의해서 데이터베이스에 row 배타락이 발생한 경우 이어서 들어오는 동일한 row에 대한 배타락 요청을 앞선 요청의 잠금이 해제될때까지 대기하게 된다. 이럴 때 잠금을 가진 요청의 처리가 길어지게 되면 커넥션 풀의 커넥션이 부족하게 되어 어플리케이션 전체가 영향을 받을 수 있다.(끔찍..) 이럴경우 잠금획득 대기시간을 설정하는 Timeout을 사용해서 데이터베이스의 잠금이 어플리케이션 전체의 장애로 확산되는 것을 방지할 수 있다. 

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2026.png)

위와 같이 설정하면 select for update 쿼리에 nowait가 추가되어 잠금을 취득할 수 없을 경우 즉시 LockTimeoutException과 같은 예외가 발생한다. 밀리세컨드 단위로 시간을 지정하는 것도 가능하다. 다만 주의할 것은 데이터베이스에 따라 지원여부가 다르고 지원하지 않는 경우 무시되므로 잘 구분해서 사용해야 한다. 예를 들어 H2는 쿼리에 Timeout을 지정할 수 없고 PostgreSQL은 nowait(0으로 설정)은 지정 가능하나 시간설정은 무시되므로 주의해야 한다. 데이터베이스 별로 동작이 다른 부분이 있으므로 커넥션 단위의 설정을 이용하거나 서킷 브레이커등을 이용하는 것이 더 바람직해 보인다.

**어떤 종류의 락을 이용할 것인지는 해당 도메인의 비즈니스 로직에 따라서 다르고 대부분의 도메인에서는 필요 없을 수도 있다. 하지만 상황에 맞는 락을 선택할 수 있도록 각각의 특성에 대해 잘 알아두자.**

[https://reiphiel.tistory.com/entry/understanding-jpa-lock](https://reiphiel.tistory.com/entry/understanding-jpa-lock)

# JPA에서 트랜잭션 동시성 처리

객체관계형 매핑 프레임워크를 사용하면 뜻하지 않게 데이터베이스가 제공하는 원자적 연산을 사용하는 대신 불안전한  read-modify-write 주기를 실행하는 코드를 작성하기 쉽다.

JPA(하이버네이트-ORM)를 사용하면 트랜잭션에 대해서 고려할 부분이 있는데 그 이유는

**격리수준**

일반적으로 주로 사용되는 데이터베이스는 주로 Read Committed에 해당하는 격리수준을 가지는 경우가 많다. 하지만 JPA를 사용할 경우 한번 영속 컨텍스트에 적재된 엔티티를 다시 조회할 경우 데이터베이스를 조회하지 않고 영속 컨텍스트에서 엔티티를 가져오므로 Repeatable Read 격리 수준과 동일하게 동작하게 된다.

그럼 JPA의 격리 수준은 어떻게 결정될까? **JPA(하이버네이트)의 격리 수준은 데이터베이스 vendor에 의해 결정**된다고 한다. 그리고 이는 **스프링의 @Transactional에 의해서도 변경될 수 있다.**

하지만 위에서 언급한 영속성 캐싱에 대한 주의는 언제나 필요하다.

한 예로 ‘쓰기 왜곡’이 있다. 어떤 값을 쓰는데 본래와 다른 내용이 써졌다 정도로 이해할 수 있겠다. 자세히 보면 다음과 같다.

영속상태의 객체를 dirty checking 매커니즘에 따라 변화가 있는 값만을 update 진행하게 된다. 그러나 dirty checking을 통한 update 당시 update의 대상이 아닌 값이 변화되었다면 해당 부분에 대해 인지를 할 수 없는 상황을 가리킨다. ex) 잔액 인출, 포인트 차감 

## 해결방안

### 낙관적 락

트랜잭션 간 lock이 발생하지 않는다는 관점이라서 낙관적 락이라고 한다. JPA에서 제공하는 @Version을 사용하며 테이블에 version 칼럼을 명시하고 update간 해당 칼럼을 +1씩 갱신한다. 트랜잭션 간 update의 대상의 version 컬럼 데이터가 영속객체의 version 데이터와 다르다면 exception을 발생시킨 후 보상 트랜잭션을 진행하는 등의 방식을 택한다.

### 비관적 락

트랜잭션 간 락이 발생할 것이라는 관점이라서 비관적 락이라고 한다. mysql에서 ~~for update와 같은 방식의 쿼리로 lock을 요청한다.

### 테스트 및 결과

특정 Id를 select한 후 연관 테이블에 값이 없으면 insert 있으면 update하는 로직.

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2027.png)

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2028.png)

insert 로직에서 에러 발생. insert 시점에 이미 unique한 값이 대상에 존재하게 되었다.

### 시도

**1.비관 락 - Pessimistic_write -성공**

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2029.png)

(repository 메소드에 lock어노테이션 추가한 것.)

쿼리를 보면 

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2030.png)

for update 쿼리로 x lock이 사용되었다. insert가 한번만 되고 나머진 다 update되었다.

**2.비관 락 - Pessimistic_read - 실패**

쿼리를 보면

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2031.png)

lock in share mode로 쿼리가 동작하였다.( 참고: MySQL 8.0부터는 기존 lock in share mode 대신 for share라고 간략하게 적어줘도 된다.) 공유락으로 진행되서 아래와 같은 데드락 발생.

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2032.png)

**3.낙관 락 - OptimisticLockException과 보상 트랜잭션 적용 - 실패**

OptimisticLockException은 말 그대로 낙관적 락을 사용한 트랜잭션 중 발생한 예외로 트랜잭션 실패 대상 entity를 반환 받을 수 있는 편의성이 존재한다.

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2033.png)

OptimisticLockException이 발생하기 전에 데드락이 발생하여 트랜잭션 실패에 대한 보상 트랜잭션을 실행할 수 없었다. 이유는 위의 duplicate key에 사로잡혀 ‘존재하지 않을 경우 insert’ 로직에만 집중한 탓. 근본적으로 version 컬럼을 만들어서 row의 갱신을 알아차리는 것이라하면 insert의 상황이 아닌 lost update의 방지책으로 쓰이는게 알맞아 보인다. 

### 무엇이 베스트일까?

위의 테스트를 진행하며 비관적, 낙관적 락을 사용하여 해결책을 찾아봤는데 insert와 update를 한 메소드에서 진행하는 특수한 케이스로 미루어보아 insert와 update 각각 상황에 맞는 locking 기법을 알맞게 사용하는 것도 중요해 보인다. 각 lock 기법의 특징과 장단점을 올바르게 파악하는 것이 필요할 것 같다. 

### 동시성 문제 - 비즈니스 애플리케이션

동시성 제어 기법 중 하나인 낙관적 락을 이용해 아키텍처를 구성하면 믿을 수 없는 재고값 문제를 해결할 수 있다. 하지만 **전체 프로세스 중에 트랜잭션의 원자성을 보장하지 못하게 하는 ‘외부 시스템 연동’ 같은 과정이 있다면 낙관적 락은 사용하기 어렵다.** 낙관적 락은 전체 프로세스의 실패를 마지막 저장 시도 시점에 알 수 있는데 원자적으로 롤백이 어려운 프로세스라면 전체 시스템의 정합성이 깨지기 때문이다. 

이런 경우, 시스템의 활동성을 조금 포기하더라도 정확성을 높일 수 있는 ‘비관적 락’을 사용할 수 있다. 비관적 락은 낙관적 락에 비해 활동성은 줄어들어 주문이 몰리는 시점에 고객은 더 느린 주문을 경험하겠지만, 결제만 되고 취소가 되는 등의 부정확한 시스템을 줄일 것이다.

[https://velog.io/@recordsbeat/JPA에서-Write-Skew-방지하기-locking-전략](https://velog.io/@recordsbeat/JPA%EC%97%90%EC%84%9C-Write-Skew-%EB%B0%A9%EC%A7%80%ED%95%98%EA%B8%B0-locking-%EC%A0%84%EB%9E%B5)

# JPA에서 트랜잭션 동시성 처리2

같은 파라미터로 온 request들을 처리하다가 발생한 오류

**Duplicate entry for unique key**

오류가 발생한 api는 특정업체 상품에 접근한 횟수를 카운트하는 기능, 업체마다 토큰을 지정하여 해당 토큰이 파라미터로 들어오는 구조.

### 예시코드

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2034.png)

1. 오늘 날짜의 접근기록 데이터(유니크) 확인
2. 존재하지 않으면 insert
3. 존재하면 count++

동시에 호출되어 두 쓰레드의 트랜잭션 모두 select 시 존재하지 않는다고 판단하여 insert를 실행하다가 한쪽 트랜잭션에서 유니크 제약에 걸려 오류가 발생한 것으로 추정된다.

**에러로그**

**ERROR Duplicate entry '884-2020-7' for key 'outlink_access_count_uk'**

이러한 문제를 쓰기 스큐(write skew), 팬텀읽기(Phantom read)라고 한다.

쓰기 스큐 : 트랜잭션이 무언가를 읽고, 읽은 값을 기반으로 어떤 결정을 내린 후 그 결정을 데이터베이스에 쓴다. 그러나 쓰기를 실행하는 시점에는 읽은 시점에 결정을 내렸던 상태와 달라 참이 아니다. 직렬성 격리만 이런 현상을 막을 수 있다.

팬텀 읽기 : 트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽는다. 다른 클라이언트가 그 검색결과에 영향을 주는 쓰기를 실행한다. 스냅샷 격리는 팬텀읽기는 막아주지만 쓰기 스큐 맥락에서 발생하는 팬텀은 색인 범위 잠금처럼 특별한 처리가 필요하다. 

위 경우는 팬텀 읽기에 조금 더 가깝다.

### 테스트

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2035.png)

쓰레드를 여러개 생성하여 호출되도록 테스트 코드를 구성하고, 호출된 횟수만큼 카운트가 증가되어야 하기 때문에 assert 조건을 쓰레드 개수와 카운트 결과 갯수로 하였다.

실행결과 문제상황이었던 **ERROR Duplicate entry '884-2020-7' for key 'outlink_access_count_uk'** 유니크 키 중복 쓰기 시도 오류 재현되었다.

다수 쓰레드에서 동시에( 1. 오늘날짜 접근기록 확인)을 실행했을때 접근 기록이 없다고 판단하여 ( 2. 존재하지 않는 경우 insert)를 실행했는데 한 쓰레드는 성공하고 나머지 쓰레드는 성공하지 못하였다.

정상적으로 동작하려면 한 쓰레드에서만 insert를 실행하고 나머지 쓰레드는 그 insert된 객체를 읽어서 카운트가 증가되도록 해야한다. 정상적으로 동작하게 하려면 어떻게 해야할까?

**몇 가지 방법**

1. 데이터를 insert하는 부분에서 exception 발생 시, catch하여 다시 한번 처음부터 메소드를 실행시킨다. 
2. 1번과 유사하게 하되, catch 블록에서 count 증가시킨다.
3. 트랜잭션 수행 과정에서 사용되는 데이터에 무조건 락을 걸도록 비관적 락을 사용한다.
4. 트랜잭션 격리 수준을 serializable로 하여 무조건 트랜잭션이 순차적으로 실행되도록 한다.

### 결과

**1,2번**

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2036.png)

서로 다른 쓰레드에서 insert 시도 및 예외 발생 확인 → 이 예외를 catch하여 처리 시도.

catch block의 outlinkAccessCountRepository.findAllByOutlinkTokenIdxAndYearAndMonth 수행과정에서 오류.

org.hibernate.AssertionFailure: null id in OutlinkAccessCountentry (don't flush the Session after an exception occurs)

⇒ catch 블럭 시작에 em.clear() 추가

: null Pointer Exception 발생. insert를 성공한 쓰레드(1)의 트랜잭션 결과를 실패한 쓰레드(2)의 트랜잭션에서 읽을 수 없다. 따라서 업데이트도 불가하다. 따라서 엔티티 매니저 문제 뿐만 아니라, 쓰레드1, 쓰레드2가 동시에 트랜잭션을 시작한 경우 1이 저장한 데이터를 2에서 읽을 수 없다. (트랜잭션마다 쿼리 수행 시 스냅샷 버전이 있고 트랜잭션 안에서는 해당 버전의 스냅샷을 보기 때문이다.)

또한, 예외 발생 시 트랜잭션에 rollback-only 마킹이 수행된다. 마킹된 해당 트랜잭션은 커밋이 불가하다. 따라서 위 문제가 다 해결되었다고 해도 catch 블럭에서 새로운 트랜잭션을 시작하지 않으면 count update를 진행할 수 없다. 

**3,4번**

3. 트랜잭션 수행 과정에서 사용되는 데이터에 무조건 lock을 걸도록 비관적 락을 사용한다.

⇒ Repository Method에 @Lock(LockModeType.PESSIMISTIC_READ), @Lock(LockModeType.PESSIMISTIC_WRITE) 사용

4. 트랜잭션 격리 수준을 serializable로 하여 무조건 트랜잭션이 순차적으로 실행되도록 한다.          ⇒ @Transactional(isolation = Isolation.SERIALIZABLE) 사용

번갈아가며 테스트 수행

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2037.png)

모든 테스트에서 데드락 예외 발생

트랜잭션을 무조건 순서대로 수행시키면 오류가 없을 것이라고 생각했는데 락 사용과정에서 문제가 발생한다. 공유락, 배타락에 대한 더 깊은 이해 필요할 것 같다.

### 문제해결

**1.org.springframework.retry:spring-retry 사용**

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2038.png)

스프링에서 제공하는 retry 라이브러리 사용

해당 메소드 수행 시 SQLException이 발생하면 다시 시도하도록 설정.

예외 발생한 트랜잭션은 abort시키고 새로 트랜잭션을 수행하는 것으로 판단된다.

쓰레드 10개로 테스트한 결과 정상동작 확인 (예외 발생 시, 다시 수행하여 count 값과 호출 횟수가 일치한다.)

**2.새 트랜잭션 생성으로 보상 트랜잭션 수행**

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2039.png)

새로운 트랜잭션을 생성하는 클래스를 만들고, catch 블록에서 새 트랜잭션 수행으로 count개수를 맞추도록.

![Untitled](JPA%20bf3fb95112394475851f04c0b732eb35/Untitled%2040.png)

retry와 동일하게 정상 동작 확인.

JPA Repository에서는 SQLException을 throw하지 않아서 catch할 수 없다. 모든 예외는 DataAccessException으로 다시 던져진다. 그래서 DataAccessException을 상속한 예외를 catch하여 처리.

[https://lion-king.tistory.com/entry/SpringJPATransaction-Write-skew-Phantom-1?category=865302](https://lion-king.tistory.com/entry/SpringJPATransaction-Write-skew-Phantom-1?category=865302)

[https://lion-king.tistory.com/entry/SpringJPATransaction-Write-skew-Phantom-2?category=865302](https://lion-king.tistory.com/entry/SpringJPATransaction-Write-skew-Phantom-2?category=865302)

# JDBC, JPA/Hibernate, Mybatis

### 영속성

- 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성
- 영속성을 갖지 않는 데이터는 메모리에서만 존재하기 때문에 프로그램을 종료하면 모두 잃어버리게 된다. 때문에 관계형 데이터베이스 혹은 객체 데이터베이스를 활용하여 데이터를 영구하게 저장하고 영속성을 부여한다.
- Persistence Layer
    - 프로그램의 아키텍처에서 데이터에 영속성을 부여해주는 계층
    - JDBC를 이용해 직접 구현할 수 있지만 Persistence framework를 이용한 개발이 많이 이루어진다.
- Persistence Framework
    - JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발할 수 있으며 안정적인 구동을 보장한다.
    - SQL Mapper와 ORM으로 나눌 수 있다.
    - EX) JPA, Hibernate, Mybatis