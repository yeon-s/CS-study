# 스프링

[김영한님 스프링 강의](https://www.notion.so/2e137273d21c4cd096e229fe2d3725c4)

# 스프링 프레임워크

- 자바 엔터프라이즈 개발을 편하게 해주는 경량급 오픈소스 애플리케이션 프레임워크
- 목표: POJO 기반의 enterprise application 개발을 쉽고 편하게 할 수 있도록 한다.
- 자바 어플리케이션을 개발하는데 필요한 하부구조를 포괄적으로 제공한다.
- 스프링이 하부 구조를 처리하기 때문에 개발자는 어플리케이션 개발에 집중할 수 있다.
- 동적인 웹사이트를 개발하기 위한 여러가지 서비스를 제공한다.

# IOC

- Inversion Of Control, 제어의 역행
- **인스턴스의 생성 및 소멸을 개발자 대신 스프링 컨테이너가 한다.**
- **따라서 낮은 결합도를 유지한다.**
    - 사용하지 않는다면, 객체 사이의 의존관계를 개발자가 직접 코딩하지 않으므로
    - **코드에 의존관계가 명시되지 않아 결합도가 떨어져 유지보수 하기 좋다.**
- IOC는 스프링 외에서도 사용된다.

[https://devham76.github.io/spring/Spring-IoC/](https://devham76.github.io/spring/Spring-IoC/)

# DI

- Dependency Injection, 의존성 주입이라는 뜻으로 IOC를 실제로 구현하는 방법
- 객체사이의 의존관계를 코드로 명시하는 것이 아니라 스프링 설정 파일에 등록된 정보를 바탕으로 컨테이너가 자동으로 처리해준다.
- XML파일에 설정한 대로 또는 Bean 객체 생성시 의존성 주입을 수행한다.
- 컨테이너가 직접 객체들 사이의 의존관계를 처리하는 것

# AOP

- 관점 지향 프로그래밍
- 핵심 비지니스 로직과 공통 로직을 분리해서 응집도가 높게 개발할 수 있도록 지원한다.
- 공통으로 사용하는 기능들을 외부로 독립된 클래스로 분리

## 컨테이너

- 객체의 생성 관리를 담당하며, 객체 운용에 필요한 다양한 기능을 제공한다.

## 흐름(웹 브라우저에서 Spring MVC로 요청했을 때)

1. 요청된 URL을 dispatcher-servlet에 전달
2. 핸들러 매핑은 해당 URL에 매핑된 컨트롤러가 있는지 검사 후 컨트롤러에 전달
3. 해당 컨트롤러가 로직을 처리
4. 결과를 ModelAndView 객체 생성 후 담아 dispatcher-servlet에 전달
5. dispatcher-servlet은 전달 받은 View(jsp)가 있는지 검사하기 위해 ViewResolver로 보낸다.
6. ViewResolver는 받은 View(jsp)가 있는지 검사 후 View로 보낸다.
7. View에서 Model과 같이 View(jsp)를 그린 후에 dispatcher-servlet으로 전달
8. 최종적으로 컨텐츠를 클라이언트에게 전달.

## Bean 객체

- 스프링에서 POJO(plain, old java object)를 빈이라고 부른다.
- 스프링 IOC 컨테이너가 관리, 생성되는 객체
    - 컨테이너에서 생성되었다는 점을 제외하면 일반 자바객체와 같다.
- new를 통해 개발자가 생성한 것은 Bean이 아니다.
- 이런 Bean들만 의존성이 주입된다.
- 빈 등록 방법
    - 어노테이션으로 명시(@Component, @Service, @Controller, @Repository)
    - xml이나 자바 설정파일에 등록
- 빈 꺼내는 방법
    - @Autowired,

[https://gmlwjd9405.github.io/2018/11/10/spring-beans.html](https://gmlwjd9405.github.io/2018/11/10/spring-beans.html)

## Bean 생성 원리

스프링 부트에서는 @SpringBootApplication 어노테이션을 run하는 메인 메소드가 있는 클래스 위에 붙이면 그 하위 패키지를 스캔한다. @SpringBootApplication의 내부를 보면 @ComponentScan, @SpringBootConfiguration, @EnableAutoConfiguration 등의 어노테이션이 붙어있고 @ComponentScan을 통해서 메인 메소드가 있는 클래스의 하위 패키지를 스캔하게 된다.

## 의존성 주입

필요한 의존성을 어떻게 주입받을 것인가

### 의존성 주입 방법은 3가지

- 생성자(권장)
- Setter
- 필드

**필드 주입 방식의 단점**

![Untitled](/image/spring2/Untitled.png)

**1. 단일 책임의 원칙 위반**

필드 주입 방식은 일단 의존성을 주입하기 쉽습니다. `@Autowired` 선언 아래 3개든 10개든 막 추가할 수 있으니... 여기서 `Constructor Injection`을 사용하면 다른 `Injection` 타입에 비해 위기감 같은 걸 느끼게 해줍니다. `Constructor`의 파라미터가 많아짐과 동시에 하나의 클래스가 많은 책임을 떠안는다는 걸 알게됩니다. 이때 이러한 징조들이 **리팩토링**을 해야한다는 신호가 될 수 있습니다.

**2. 불변성(Immutability)**

`Constructor Injection`과 다르게 `Field Injection`은 `final`을 선언할 수 없습니다. 그래서 객체가 변할 수 있습니다.

생성자를 생성하는 게 귀찮으므로 @RequiredArgsConstructor를 사용

⇒ final이나 @NotNull이 붙은 필드의 생성자를 자동으로 생성해주는 롬복 어노테이션

**이거보기**

[https://devlog-wjdrbs96.tistory.com/166](https://devlog-wjdrbs96.tistory.com/166)

## 스프링을 쓰는 이유

- 스프링 이전에는 EJB(Enterprise Java Beans)로 개발되었다.
- EJB는 EJB 컨테이너가 제공하는 많은 기술과 장점에도 불구하고
    - 스펙이 너무 복잡해서 학습에 많은 시간이 필요하다.
    - 개발 및 유지 보수하기에 복잡하고 힘들다.
    - 툴의 도움없이는 다루기 힘든 난해한 설정, 까다로운 패키징, 불편한 서버 배치 등 때문에
    - **고가의 느리고 무거운 자바 서버가 필요했다.**
    - EJB를 제대로 사용하려면 디자인 패턴을 이해하고 적용할 수 있어야 한다.(성능 유지, 유지보수의 편의성을 위해)
- 이를 보완하기 위해 나온 것이 Spring이다.
    - 평범한 POJO를 사용하면 EJB에서만 가능했던 많은 일을 가능하게 한다.
    - 스프링 프레임워크는 이미 많은 디자인 패턴이 적용되어 배포되므로 프레임 워크를 사용하는 것 자체가 디자인 패턴을 사용하는 것이다.
    - 톰캣같은 기본적인 웹 서버로도 운영 가능하다.

JSP, Servlet, PHP 등이 있는데 왜 Spring이라는 프레임 워크를 사용해야 할까? 먼저 스프링이 나타나기 이전의 자바 Enterprise Project 중 80%가 실패했다. 엔터프라이즈 시스템 개발이 너무 복잡했기 때문이다. 시스템 개발시 비즈니스 로직 이외에도 고려할 사항이 많았기 때문에.( 타 시스템과의 연계, 분산 트랜잭션 지원, 보안 등) 또한 개발이 진행됨에 따라 비즈니스 로직이 복잡해지고 잦은 변경이 요구되기 때문이다. 

스프링은 이런 복잡함을 해결하기 위해 DI, IOC, AOP, PSA의 특징을 가지고 있다. ⇒ 객체지향 개발 용이하게 할 수 있도록 도와준다. ⇒ 유지보수 용이, 유연성, 확장성, 개발 속도 향상, 재사용성

애플리케이션을 빠르고 효율적으로 개발할 수 있도록 기본 틀과 공통 프로그래밍 모델, API 등을 제공한다.

타 시스템과의 연계 : PSA(추상화를 통해 특정 기술이나 환경에 종속적이지 않다.)

- 스프링 컨테이너가 싱글톤으로 빈을 관리해서 멀티쓰레드 환경에서 공유함으로써 성능 저하 막고 메모리 절약할 수 있다. (엔터프라이즈 개발에서 예상할 수 있듯이 트래픽이 많을 것이다. → 많은 쓰레드에서 각각 객체 생성하면 메모리 낭비와 성능 저하 발생할 것이다.)
- 비즈니스 로직에만 집중할 수 있도록 다양한 기능을 제공하고 개발 기간을 단축시킬 수 있다.
- 스프링의 장점은 트랜잭션과 복잡한 멀티 스레드 상황을 컨테이너가 처리해준다는 점이다. 따라서 개발자는 싱글 스레드 애플리케이션처럼 단순하게 개발할 수 있고 결과적으로 비즈니스 로직 개발에 집중할 수 있다.
- 추상화 : 스프링은 어플리케이션 구현에 필요한 대부분의 기술들을 추상화하여 제공해주고 있어서 해당 기술들을 쉽고 빠르게 사용 가능
- AOP 때문에 스프링을 쓰는겁니다. 자바는 하나의 클래스에 대한 수직적인 흐름만 제어할 수 있는 반면 스프링을 쓰면 특정 클래스들에 대한 수평적인 제어가 가능해 집니다. 가령 *Controller.do 패턴이 들어오면 전처리로 OO 빈 클래스를 실행하라. 이런 선언이 가능한 것이죠.수직적인 제어로 불완전 했던 Java 가 스프링을 만나며 수직, 수평 제어 모두 가능하게 되어 비로서 강력한 언어로 입지를 갖게 되었습니다.
- 저는 Spring을 쓰는 이유의 가장 큰 것은 DI(의존성주입), IoC(제어 역전), Test 때문이라고 생각합니다. 보통 클래스 내부에서 new 로 객체의 인스턴스를 받아서 사용하는 방식은 모듈간의 강한결합을 불러옵니다. 그래서 변경이나 확장 등에서 자유롭지 못하게 됩니다. 하지만 생성자, setter 등으로 외부에서(스프링에 의해 객체의 생명주기가 관리됨:IoC) 생성된 객체의 인스턴스를 받아서 사용만(의존관계에 있는 객체가 외부로 부터 받음:DI)하는 구조로 개발을 해 놓으면 변경이 있을때 해당하는 부분의 클래스만 변경이 가능합니다. 이런 구조를 가능하게 하는 것이 인터페이스를 사용했을때 가능한데요. Spring을 사용하면 그런 인터페이스를 먼저 만들고, 그에 대한 구현체를 만드는 페턴이 자연스레 됩니다. 그렇게 되면 모듈 단위의 테스트를 하기에도 매우 쉽습니다. 하지만 반대로 생각하면 특정기능을 너무 많은 인터페이스와 구현체로 쪼개는 결과를 불러와서 관리하기 어렵다는 말도 나올 수 있는데요. 단점이 주는 어려움보다 장점이 주는 편리함이 더 크기때문에 Spring은 앞으로도 많은 인기를 얻을 것 같습니다.
- spring data jpa, spring data jdbc 등 어플리케이션 개발에 필요한 기능들을 제공해주어 쉽고 편하게 사용할 수 있다.
- 트랜잭션과 멀티쓰레드 상황을 처리해준다. 따라서 멀티쓰레드 신경안쓰고 로직에 집중할 수 있다. 트랜잭션 AOP로 인해 중복 코드 없애고 jpa를 사용할때 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간 공유하면 안되는데 스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당하고 트랜잭션마다 다른 영속성 컨텍스트를 사용하므로 멀티쓰레드 상황에 안전하다.
- **PSA :** 스프링을 사용하면 서비스 추상화를 통해 특정 환경이나 서버, 기술에 종속되지 않으며 유연한 애플리케이션을 개발할 수 있다. 스프링에서는 추상화 계층을 통해 구체적인 기술과 환경에 종속되지 않도록 한다. 예를 들어 MyBatis나 JPA 등 세부 기술에 종속적인 에러들을 추상화하여 기술에 종속적이지 않은 에러들로 처리할 수 있도록 도와준다. 스프링을 자세히 공부하다 보면 추상화를 위해 프록시(Proxy) 패턴과 같은 디자인 패턴이 매우 자주 사용됨을 파악할 수 있다.
- AOP : AOP(Aspect Oriented Programming, 관점 지향 프로그래밍)는 **애플리케이션에 공통적으로 나타나는 부가적인 기능들을 독립적으로 모듈화**하는 프로그래밍 모델이다. 애플리케이션의 요구 사항이 점점 복잡해져가고, 기술적인 난해함이 더해지면 모든 **책임과 관심사를 분리**하는 것이 상당히 어렵다. 그래서 스프링은 AOP를 지원하여 다양한 엔터프라이즈 서비스를 적용하고도 책임을 분리하여 깔끔한 코드를 유지할 수 있고, 객체지향스럽게 개발할 수 있도록 도와준다.예를 들어 비즈니스 로직과 트랜잭션 관리를 위한 로직이 결합된다면 로직이 중복되고, 여러 책임을 갖는 등의 단점이 존재하게 된다. Spring에서는 AOP를 적용하여 @Transactional이라는 선언적 트랜잭션 기능을 구현하여 큰 장점을 누릴 수 있도록 도와준다.

[https://mangkyu.tistory.com/156](https://mangkyu.tistory.com/156)

# 스프링 쓰는 이유

[https://ojt90902.tistory.com/861?category=967948](https://ojt90902.tistory.com/861?category=967948)

### DI

**의존성**

프로그램 개발을 진행하다 보면 객체간의 의존성이 생기기 마련이다.

이런 의존성에 의한 문제로는 **코드의 변경이 어려워 진다는 점**이다. 

⇒의존성 주입으로 해결 ⇒ 코드의 수정이 용이해진다.(한 클래스를 수정할때 다른 클래스를 수정해야하는 상황을 막아준다.)

위와 같은 이유로 스프링은 DI(의존성 주입)을 통해 모듈간의 결합도를 낮춰준다. IOC 컨테이너가 개발자 대신 xml 파일에 정의된 대로 Bean 객체를 생성하고 의존성을 대신 주입해준다. IOC란 제어의 역전이라는 말로 개발자가 직접 객체를 생성하고 관리하던 것을 스프링의 IOC 컨테이너가 대신 해준다는 것이다.

DI를 통해 개발자가 해야하는 일은 다음과 같아졌다.

- Bean 클래스 작성
- 주입을 위한 설정(xml 파일 기술 또는 어노테이션(@)사용)

### IOC

IOC 컨테이너란 사용자가 작성한 메타데이터(xml 파일 또는 어노테이션(@)에 따라  Bean 클래스를 생성 및 관리하는 스프링의 핵심 컴포넌트이다.

IOC 컨테이너 설정 방법

- XML 파일 기술
    - XML 파일을 이용하여 설정하게 되면 코드와 의존성을 주입하는 부분을 분리할 수 있다. 따라서 유지보수성을 높일 수 있다. 하지만 시스템이 거대해지다 보면  XML파일이 너무 많아져 오히려 유지보수가 어려워진다.
    - 장점: 각 객체들간의 의존관계를 한눈에 볼 수 있다.
    - 단점: 규모가 커짐에 따라 XML에 기술할 내용이 많아지면 생산성이 저하 된다.
- 어노테이션 사용
    - XML의 단점 때문에 등장
    - 장점: 보다 더 직관적인 코드 작성이 가능해진다. 개발 생산성이 증대 된다.

## AOP

애플리케이션에 공통적으로 나타나는 부가적인 기능등을 독립적으로 모듈화한다. 애플리케이션 요구 사항이 점점 복잡해져가고, 기술적인 난해함이 더해지면 모든 **책임과 관심사를 분리하는 것**이 어렵다. 그래서 스프링은 AOP를 지원하여 다양한 엔터프라이즈 서비스를 적용하고도 책임을 분리하여 깔끔한 코드를 유지할 수 있고, 객체지향스럽게 개발할 수 있도록 도와준다. 예를 들어 비즈니스 로직과 트랜잭션 관리를 위한 로직이 결합된다면 로직이 중복되고, 여러 책임을 갖는 등의 단점이 존재하게 된다. (여러 책임을 가지면 유지보수가 어렵다.) 스프링에서는 AOP를 적용한 @Transactional이라는 선언적 트랜잭션 기능을 제공해 깔끔하게 해결해준다.

## POJO

Plain Old Java Object. POJO는 말 그대로 해석을 하면 오래된 방식의 간단한 자바 오브젝트라는 뜻이다. JAVA EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 ‘무거운’ 객체를 만들게 된 것에 반발해서 사용하게 된 언어이다.

좀 더 풀어서 설명하자면 특정 ‘기술’에 종속되어 동작하는 것이 아닌 순수한 자바 객체를 말하는 것이다.

**왜 POJO를 지향해야 하는가?**

스프링 프레임워크 이전에는 원하는 엔터프라이즈 기술이 있다면 그 기술을 직접적으로 사용하는 객체를 설계했습니다. 특정 기술과 환경에 종속되어 의존하게 된 자바 코드는 가독성이 떨어져 유지보수에 어려움이 생겼습니다. 또한, 특정 기술의 클래스를 상속받거나, 직접 의존하게 되어 확장성이 떨어지는 단점이 있었습니다. 이 말은 객체지향의 화신인 자바가 객체지향 설계의 장점들을 잃어버리게 된 것입니다.

그래서 POJO라는 개념이 등장했습니다. 본래 자바의 장점을 살리는 ‘오래된’방식의 ‘순수한’자바객체입니다.

**그럼 특정 기술을 사용하고 싶다면?(스프링이 POJO를 유지하면서 하이버네이트를 사용할 수 있는 이유)-PSA**

하이버네이트는 스프링 개발에서 많이 사용하고 있는 기술입니다. 특정 기술에 종속적이면 POJO가 아니라면서 스프링에서는 어떻게 가능한 것일까요? 바로 스프링에서 정한 표준 인터페이스가 있기 때문입니다. 스프링 개발자들은 ORM이라는 기술을 사용하기 위해 ‘JPA’라는 표준 인터페이스를 정해두었습니다. 그리고 이제 여러 ORM 프레임워크들은 이 JPA라는 표준 인터페이스 아래 구현되어 실행됩니다. 이것이 스프링이 새로운 엔터프라이즈 기술을 도입하면서도 POJO를 유지하는 방법입니다. (그리고 이것을 스프링의 PSA라고 얘기합니다.)

[https://siyoon210.tistory.com/120](https://siyoon210.tistory.com/120)

**이거보기**

[https://12bme.tistory.com/157](https://12bme.tistory.com/157)

# HttpServletRequest

# 스프링의 멀티 스레드, 싱글톤, 스레드-safe

[https://fbtmdwhd33.tistory.com/256](https://fbtmdwhd33.tistory.com/256)

# 스프링 다중 요청

[https://velog.io/@sihyung92/how-does-springboot-handle-multiple-requests](https://velog.io/@sihyung92/how-does-springboot-handle-multiple-requests)

# 스프링 Servlet Container, Spring Container

[https://jypthemiracle.medium.com/servletcontainer와-springcontainer는-무엇이-다른가-626d27a80fe5](https://jypthemiracle.medium.com/servletcontainer%EC%99%80-springcontainer%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4-%EB%8B%A4%EB%A5%B8%EA%B0%80-626d27a80fe5)

# 스프링 Application Context, Servlet Context

[https://jeong-pro.tistory.com/222](https://jeong-pro.tistory.com/222)

# 동시성 이슈

여러 쓰레드가 동시에 같은 인스턴스의 필드 값을 변경하면서 발생하는 문제이다. 

## WAS와 멀티 쓰레드

톰캣과 같은 서블릿을 지원하는 WAS는 서블릿 컨테이너이며, 멀티 쓰레드와 관련된 처리를 지원한다. 따라서 개발자는 멀티 쓰레드 관련 코드를 신경쓰지 않고 싱글 쓰레드 프로그래밍을 하듯 코드를 작성하면 된다. 하지만 멀티 쓰레드 환경에서 주의하면서 코딩해야 하는 부분이 있는데 그 중 하나가 동시성 이슈에 관한 부분이다. 

## 싱글톤

스프링 bean scope는 기본적으로 싱글톤이다. 즉, 스프링 DI 컨테이너당 하나의 인스턴스만 사용된다. 

![Untitled](/image/spring2/Untitled%201.png)

### 위 코드는 올바르게 작성된 코드일까?

- 싱글톤 객체를 사용할 때는 동시성 이슈가 발생하지 않도록 조심히 사용해야 한다.

### 프로세스 메모리 영역

프로세스 메모리 영역은 크게 4가지로 구성되어 있다.

- stack: 매개변수, 지역변수 등 임시적인 자료
- heap: 동적으로 할당되는 메모리
- data: 전역 변수
- text: 프로그램의 코드

이 중 data는 BSS와 GVAR로 구성되어 있다. BSS는 초기화하지 않은 데이터가 저장되고 GVAR은 초기화된 데이터가 저장된다. data 영역이 이렇게 두개로 분리된 이유는 초기화된 데이터는 초기화되지 않은 변수와 다르게, 해당 값을 프로그램에 저장하고 있어야 한다. BSS영역은 초기화되지 않은 데이터가 저장되기 때문에 프로그램이 실행될때 영역만 차지하고 그 값을 프로그램에 저장하고 있을 필요가 없기 떄문이다.

### 쓰레드는 프로세스의 어떤 영역을 공유하지 않을까?

동시성 이슈를 이해하는데 중요한 포인트이다.

- WAS는 요청당 하나의 쓰레드를 생성한다. 그리고 쓰레드는 별도의 stack 영역을 갖고 있으며 스택 영역을 제외한 프로세스 메모리 영역을 공유한다.
- 따라서, 싱글톤 객체에서 상태값을 갖도록 설계한다면 해당 상태 값은 프로세스의 data 영역에 들어갈테고, 모든 쓰레드가 공유하기 때문에 동시성 이슈가 발생할 수 있다.
- 동시성 이슈는 값을 읽기만 해서는 발생하지 않으면 변경이 일어나야만 발생하는 문제이다.

쓰레드는 별도의 스택영역을 갖기 때문에 인스턴스를 갖도록 설계하지 않고 지역변수나 매개변수 등으로 객체를 넘겨서 사용하게 되면 적은 노력으로 동시성 이슈를 피할 수 있다.

### 그렇다면 싱글톤 객체에서 상태값을 갖도록 설계할 수는 없을까?

싱글톤 객체를 만들면서 상태값을 갖도록 해야하는 경우가 있을 수 있다. 이러한 경우 쓰레드로컬(ThreadLocal)을 활용하면 된다.

![Untitled](/image/spring2/Untitled%202.png)

위 처럼 쓰레드로컬을 적용하여 사용하면 각 쓰레드는 userId를 가져오기 위해 **자신만의 별도의 내부 저장소**에서 꺼내기 때문에 동시성 이슈로부터 안전하다.

### 쓰레드 로컬 사용 주의점

쓰레드 로컬 사용시 주의해야하는 점이 있다. 바로 쓰레드로컬을 모두 사용하고 나면 ThreadLocal.remove()를 호출해서 스레드 로컬에 저장된 값을 제거해줘야 한다. 쓰레드 로컬은 스프링 시큐리티의 시큐리티컨텍스트홀더에서 사용되는 전략이다. 만약 제거하지 않으면 WAS처럼 쓰레드 풀을 사용하는 경우에 심각한 문제가 발생할 수 있다.

**시나리오**

- 사용자 A가 회원가입 요청을 한다.
- WAS는 쓰레드 풀에서 놀고 있는 쓰레드-A를 꺼내서 할당한다.
- 쓰레드-A가 사용자 A의 데이터를 쓰레드로컬 자신의 전용 보관소인 스토리지-A에 저장한다.
- A의 요청이 끝나고 사용했던 쓰레드-A를 쓰레드 풀에 반납한다.(쓰레드-A가 제거되지 않았으므로 스토리지-A도 살아있다.)
- B 사용자가 자신의 정보 조회 요청을 한다.
- WAS가 다시 쓰레드를 할당하기 위해 쓰레드 풀에서 꺼내는데 (이때 어떤 쓰레드가 할당될지는 모른다.) 쓰레드-A가 할당되었다!!
- 따라서 B사용자가 사용자 A의 정보를 조회해서 볼 수 있게 된다.

이러한 이유 때문에 쓰레드로컬을 사용하면 꼭 remove해줘야 한다.

### 쓰레드 Safe하게 설계하는 방법

- java.util.concurrent 패키지 하위의 클래스 사용하기 (EX. ConcurrentHashMap 등)
- 상태 값 두지 않기
- LazyHolder 방식의 싱글톤 패턴 사용
    - 인스턴스가 1개만 생성되는 특징을 가진 싱글톤 패턴을 이용하면 하나의 인스턴스를 메모리에 등록해서 여러 스레드가 동시에 해당 인스턴스를 공유하여 사용하게끔 할 수 있으므로 요청이 많은 곳에서 사용하면 효율을 높일 수 있다.
    - 보통은 LazyHolder 방식을 주로 사용한다.(JVM의 Class Loader 매커니즘을 이용한 방법)
- 동기화 블럭 지정(synchronized)

### 빈으로 등록된 서비스에서 하나의 파일을 공유하여 읽고 쓰는 경우 동시성 이슈가 발생할까?

**시나리오**

- 빈으로 등록되어있는 service에서 파일 쓰기, 읽기 작업을 하는 메서드 (파일을 쓰고→ 읽는 작업을 수행하는 메서드)를 제공하고 있으며
- 여러 쓰레드가 하나의 파일(Ex. file.txt)을 가지고 읽기, 쓰기 작업을 수행중이라고 할 때
    - 파일 쓰기 작업을 하기 위해서 Writer 객체의 write를 사용
    - 읽기 작업은 Files.readAllLines 사용
- 쓰레드는 A,B,C 3개가 존재하며 각 스레드 이름별로 A,B,C 문자열을 파일에 기록하고 싶어한다.
- 즉, 쓰레드-A는 문자열 A가 적힌 파일을 원하며, 쓰레드 B는 문자열 B가 적힌 파일을 원한다.

**문제**

- 동시성 이슈가 발생할지, 발생하지 않을지에 대해 이유.
- 읽기 작업에 대해서 일관성이 보장 되는지, 되지 않는지에 대해 이유.

**테스트 케이스 1: Writer를 상태로 두고 공유해서 사용하는 경우**

![Untitled](/image/spring2/Untitled%203.png)

![Untitled](/image/spring2/Untitled%204.png)

**테스트 케이스 2: 매개변수로 넘겨서 별도의 Stack 영역을 사용하는 경우**

![Untitled](/image/spring2/Untitled%205.png)

![Untitled](/image/spring2/Untitled%206.png)

**해설**

write() 메서드의 경우 내부적으로 synchronized lock을 구현하고 있고 읽기의 경우 별도로 lock을 제공하고 있지 않는다.

동시성 이슈를 피하기 위해 가급적 상태를 갖도록 설계하면 안된다는 것과, 상태를 가지면 동시성 이슈가 발생할 수 있다고 했다. write() 메서드 내부에서 synchronized lock을 제공하고 있는데 그러면 동시성 이슈가 발생하지 않는가?

**케이스1**

- 클라이언트의 스레드-A 입장에서는 파일을 쓰고 읽을 때 A가 찍히길 기대하지만 원하는 읽기 일관성을 얻지 못한다. 그 이유는 Files.readAllLines에서는 synchronized가 없기 때문이다.
- Writer를 상태로 관리하더라도 write 메서드에서는 synchronized lock을 제공하고 있기 때문에 동시성 이슈가 발생하지 않을 것만 같다.
- 출력 결과는 Writer를 공유하고 있어서 파일에는 작업이 먼저 끝난 쓰레드 순서대로 ABC,ACB등의 문자열이 찍혀있을 것이다.

**케이스2**

- 매개변수로 넘겨서 사용하면 각 스레드마다 별도의 Stack 영역이 생기므로 동시성 이슈가 발생하지 않을 것만 같다.
- 출력 결과는 마지막에 작업이 끝난 쓰레드를 기준으로 해당 문자열만 파일에 적혀있을 것이다.
- 읽기 일관성은 보장하지 못한다.
- 만약에 FileService의 write 메서드에 synchronized를 적으면 어떻게 될까?
    - 동시성 이슈가 발생하지 않을 것만 같다.
    - 읽기 일관성이 보장된다.
    - 별도의 writer 객체를 사용하기 때문에 쓰레드 A,B,C 순서대로 작업을 하게되면 마지막에 끝난 쓰레드-B를 기준으로 해당 문자열만 파일에 적혀있다.

### 결론

동시성 이슈는 상태값을 변경하기 때문에 발생하는 것이라고 했다. 따라서 이문제에서 상태를 어떤 것으로 볼 것이냐가 중요하다고 생각했다. **모든 스레드가 공유하고 있는 하나의 파일안의 내용을 인스턴스 필드값이라고 가정하면** Writer 객체를 메서드 내부에서 생성해서 쓰던 필드로 관리하던 파일을 읽고/쓰는 메서드를 호출하는 클라이언트 입장에서는 동시성 이슈가 발생한 것처럼 보일 것이다.

[https://techvu.dev/143](https://techvu.dev/143)

# @Transactional

스프링의 @Transactional 어노테이션을 사용하면 트랜잭션 관련 문제가 발생할 시 롤백시킬 수 있으며 동시성 문제에 대한 걱정도 해결할 수 있다.

단순히 @Transactional 어노테이션만 붙여주면 트랜잭션 고립 레벨은 jdbc 기본 트랜잭션 격리 수준을 따르게 된다. 만약 MySQL이나 MariaDB을 사용중이라면 default로 Repeatable Read, 오라클은 Read Committed이다.

고립 레벨이 높다고 해서 좋은 것은 아니다. 고립성이 높아지는 만큼 동시성이 낮아지고 다른 트랜잭션에서 제한되는 점이 많아 성능이 떨어진다.  

# @ResponseEntity, @ResponseBody, @RequestBody, @RequestMapping,

스프링에서 HTTP 처리 (HTTP 컨버터)

싸피 스프링 강의, 국비 스프링 자료 참고
