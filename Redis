# Redis 강의

## Redis를 학습해야 하는 이유

- 손쉽게 사용이 가능한 인메모리 저장소
- 높은 성능
- 다양한 데이터 타입으로 유연성 제공,여러 기능 구현 가능
- 서비스의 속도 향상 및 많은 트래픽을 감당해야하는 현대적인 서버 구조에서 분산환경의 캐시, 세션 관리가 거의 필수

## 학습 목표

- 레디스가 무엇인지 특성 중심으로 설명할 수 있다.
- 세션 스토어, 캐시 같은 레디스의 주요한 활용 방법을 익히고 구현할 수 있다.
- 클러스터 구성, 백업과 장애 복구 등 실제 레디스 운영에 필요한 지식을 갖춘다.
- 레디스를 활용하는 다양한 어플리케이션 아키텍처들을 익힌다.

# 레디스 소개와 특징

## 1. *인메모리 디비로서의 레디스*

### 레디스의 정의

- Remote Dictionary Server
- 스토리지:  데이터 저장소(데이터 관점)
- 데이터베이스 : DB 역할을 수행(영속성 관점) ⇒ 백업같은 추가적인 기능을 이용해야 가능
- 미들웨어 : 어플리케이션이 이용할 수 있는 유용한 기능을 제공하는 소프트웨어

### 레디스로 할 수 있는 것

- 아주 빠른 데이터 저장소로 활용
- 분산된 서버들간의 데이터 공유(동기화, 작업 분할 등)
- 내장된 자료구조를 활용한 기능 구현( Sorted Set으로 랭킹 구현 등)
    - 지금도 기능이 많이 추가되고 있음.( 카프카에서 제공하던 Pub/Sub, 스트링 기능 등)

### 디비를 쓰는 이유?

- 어플리케이션에서도 파일을 만들어 데이터를 저장할 수는 있다. 하지만 매번 불필요한 노력이 들어가는 것 보다 데이터를 저장하는 기능을 가진 소프트웨어를 구현하면 계속 쓸 수 있기 때문.
- 관심사의 분리, 계층화
    - 비즈니스 로직에만 집중해서 개발가능, 문제가 생겼을 때 분리해서 볼 수 있다.

### 인메모리 디비?

- 데이터를 디스크에 저장하지 않는다.
- 보통 램을 뜻함.(휘발성)
- 빠른속도, 비싼가격

![스크린샷 2023-03-18 오전 1.54.28.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-18_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_1.54.28.png)

휘발성의 문제를 감수하더라도 빠른 속도를 요구하는 니즈 발생

### 빠른 속도와 휘발성의 절충

- 용도에 맞게 디비와 레디스를 사용(세션 데이터 같은 단기적인 데이터를 레디스에 저장, 영속성을 가져야하는 데이터는 디비에 저장)
- 캐시로 사용
- 레디스가 제공하는 백업 방식을 사용해 영속성 확보(디비보다는 영속성이 약하기에 절대적인 무결성을 필요로 하는 데이터는 디비에 저장)

## 2. *Key-Value Store로서의 레디스*

### 데이터 저장소의 구조

- DB의 데이터 모델 관점에서의 구조(네트워크 모델, 계층형 모델(Tree), 관계형 모델,그래프 모델, …)
    - 데이터 모델의 특성에 따라 성능 특성이 달라지게 된다.

### Key-value Store?

- 특정 값을 key로 해서 그와 연관된 데이터를 value로 저장(map과 같음)
- 가장 단순한 데이터 저장 방식
- 단순한 만큼 빠르고 성능이 좋다.

### Key-value 구조의 장점

- 단순성에서 오는 쉬운 구현과 사용성
- 해시를 이용해 값을 바로 읽으므로 속도가 빠름
- 분산 환경에서의 수평적 확장성(중요한 장점)

### Key-value 구조의 단점

- 키를 통해서만 접근이 가능하다.(데이터 검색을 할 수 없다.)
- 범위 검색(between)같은 복잡한 질의가 불가능하다.

**단순한 구조의 데이터로 높은 성능과 확장성이 필요할 때 key-value 스토어를 활용한다.**

## 3. *Redis의 등장과 활용*

### Redis 히스토리

- 2009년 이탈리아 개발자 살바토레 산필리포가 개발
- 관계형 DB의 성능적인 한계에 부딪혀 개발
- 다양한 언어에서 Redis를 지원하고 많은 라이브러리가 존재한다.(쉽게 사용할 수 있는 환경이 만들어져있다.)

### Redis 활용

- 세션 스토어
- 캐시
- Limit Rater(특정 api의 분당 호출 수 제한하는 기능)
- Job Queue(여러 서버들 간의 Job을 저장해놨다가 한쪽에서 소비해가고 하는 기능)

**다양한 기능을 제공하고 다양하게 활용할 수 있다.**

# NOSQL과 Redis

## 1. 관계형 DB의 이해

관계형 DB(관계형 데이터 모델 사용) vs NOSQL(다른 데이터 모델 사용)

### 관계형 DB란?

관계형 모델에 기초한 데이터베이스

- 관계(relation) : 속성들로 이루어진 집합. DB에서 테이블이라고 부르는 것.

### SQL

- 관계형 DB를 관리하기 위해 설계된 질의 언어
- 자료 검색, 수정, 스키마 관리 등을 할 수 있다.

### 관계형 DB의 장점

- 데이터 무결성 유지에 용이하다.(정규화를 통해 중복을 제거)
- SQL을 통해 복잡한 질의를 수행 가능

### 관계형 DB의 단점

- 고정된 스키마를 정의해야 한다.
- JOIN으로 인한 성능 문제
- 데이터들이 복잡한 관계를 맺고 있기 때문에 수평적 확장성이 떨어진다.(조인을 해야하기 때문)

## 2. NOSQL의 이해와 DB들 살펴보기

### NOSQL의 등장배경

2000년대 개발 환경의 변화

- 스토리지 비용이 내려감(하드디스크,램 등) ⇒데이터 중복이 스토리지 용량 면에서는 큰 이슈가 아니게 되었다.( 관계형 DB의 장점 중 하나는 정규화로 인한 데이터 중복을 줄여 용량 이점이 있었다.)
- 다루는 데이터의 크기와 성능 요구사항이 커졌다.(고성능 데이터 모델이나 데이터 분할이 필요해졌다.)
- 분산 환경의 대중화(스케일 아웃)
- “단순한 대량의 데이터가 다루기 쉽다”라는 새로운 개발 패러다임이 자리잡힘

**기존에는 정규화가 잘 된 복잡한 데이터들을 한 곳에 저장했다면 이제는 약간의 중복을 감수하더라도 분산하여 저장해 다루는게 새로운 패러다임이 되었다.**

### NOSQL의 종류

![스크린샷 2023-03-19 오후 5.42.10.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-19_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.42.10.png)

Document : key-value 스토어의 value 안에 오브젝트 형태가 들어간다. xml이나 json을 사용해 객체 형태로 표현. 

Wide-column : 각 데이터마다 다른 스키마를 가질 수 있다. (유연하게 사용가능)

Graph : 관계를 표현하기 용이. 노드의 순회를 통해 데이터 탐색.

## 3. NOSQL로서의 Redis

### Redis는 DBMS인가?

- 데이터를 다루는 인터페이스를 제공하므로 DBMS의 성격이 있다. (데이터 삽입, 조회 등)
- 기본적으로 영속성을 위한 DB는 아니다.
- 영속성을 지원 가능(백업을 통해)
- DBMS보다는 빠른 캐시의 성격으로 대표된다.
- 보통 영속성을 위한 RDB를 쓰며 덧붙혀서 사용하는 형태로 Redis 사용

### Redis의 다양한 특성

- 기본적으로 NOSQL DB로 분류되는 key-value store
- 다양한 자료구조를 지원(String, Hash, Set, List 등) ⇒ 다른 기능들을 쉽게 구현할 수 있다.
    - 예를 들면 Sorted Set을 이용해 랭킹 시스템을 쉽게 구현하는 것.

![스크린샷 2023-03-19 오후 5.53.49.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-19_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.53.49.png)

### External Heap(외부 메모리)로서의 Redis

- Redis는 내부 메모리를 사용하듯이 데이터를 쓸 수 있고 읽을 수 있다. 그런데 이 메모리는 외부에 있기 때문에 어플리케이션이 장애가 나도 Redis의 데이터는 보존(단기로)된다.
- 어플리케이션이 여러 머신에서 돌아도 같은 데이터를 접근 가능하다.

### DBMS로서의 Redis

- Redis에서 제공하는 백업 기능을 이용해 영속화 DBMS처럼 이용가능.
- 하지만 Redis를 사용하는 이유가 빠른 속도이기에 일반 RDB처럼 Redis를 사용하는 것은 비효율적.

### 미들웨어로서의 Redis

- Redis가 제공하는 자료구조가 다양하고 계속 추가되고 있다. 유용한 기능들이 더 추가되고 새로운 활용케이스가 나올 것이다.
- 다양한 형태의 아키텍처를 쉽게 구현할 수 있는 도구가 되어가고 있다.

**레디스가 다양한 기능을 제공하지만 인메모리 솔루션이라는 점에서 오는 특징을 활용할 때 가장 효율적이다.**  

# Redis 설치와 실습

## 1. Redis 설치

### Docker

- 경량화된 가상 환경인 컨테이너를 이용해 프로그램을 실행할 수 있는 기술
- 실행 환경을 매번 새로 설정할 필요 없이 간편하게 실행 가능
- 컨테이너가 하나의 가상 pc 역할을 해서 클러스터 같은 여러대의 pc로 돌릴때 용이

## 2. Redis 커맨드 실습

### Redis 모듈

- 레디스 모듈은 두개가 있다.
- redis-server : 레디스 기능을 담고 있는 레디스 서버
- redis-cli : 레디스 서버에 커맨드를 실행할 수 있는 인터페이스

도커 컨테이너 안에 레디스를 띄우면 레디스 서버가 돌고 있고 레디스는 컨테이너 안에 있기 때문에 redis-client를 실행하기 위해서는 컨테이너 안에서 실행해야 한다. 

![스크린샷 2023-03-24 오후 6.40.12.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.40.12.png)

![스크린샷 2023-03-24 오후 6.42.18.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.42.18.png)

docker 컨테이너 안에서 뭔가를 실행하기 위한 명령어 : exec

-it 옵션으로 이후에 계속 커맨드를 입력할 수 있게함.

my-redis는 컨테이너 이름

/bin/sh는 실행할 커맨드 : 쉘 명령어 

![스크린샷 2023-03-24 오후 6.46.10.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.46.10.png)

![스크린샷 2023-03-24 오후 6.46.45.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.46.45.png)

# 4. Redis Data Type의 이해

레디스는 key-value 스토어인데 value가 다양한 데이터 타입을 지원한다.

저마다 각자의 성능과 특성을 가지고 다른 목적에 따른 기능을 제공한다.

## 1. Strings

### String 요약

- 가장 기본적인 데이터 타입으로 많이 사용된다.
- 키 하나에 문자열이 하나 저장되는데 문자열이 저장될때 바이트 배열로 저장된다. (이것을 binary-safe라고 표현한다. binary-safe는 모든 문자를 표현할 수 있다는 의미)
- 바이너리로 변환할 수 있는 모든 데이터를 저장 가능(JPG와 같은 파일들)
- 이론적으로는 어떤 데이터든 넣을 수 있다. 주로 많이 사용하는 부분은 캐시. 웹브라우저에서 표시되는 웹 콘텐츠, html 태그로 이루어진 것들을 저장하기도 한다
- 한 키에 담을 수 있는 데이터의 최대 크기는 512mb이다.

![스크린샷 2023-03-24 오후 7.06.23.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-24_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.06.23.png)

- INCR, DECR 두개의 명령어는 atomic하다. (race condition에 걸리지 않는다. 안전하다.)
- 이런 특성은 레디스 활용성을 높이는데 도움이 된다. 예를 들어, 게시물의 좋아요 수를 실시간으로 counting하고 공유하고 싶을 때 활용 가능. 서버를 분산시켰을 때 여러 서버에서 한 레디스로 incr, decr를 빈번하게 호출해도 atomic하기 때문에 연산 결과가 중복이나 누락없이 정확한 결과가 저장된다.
- mset, mget은 set이나 get을 작은 사이즈로 여러번 호출하게 되면 네트워크 비용이 높아진다. 한번의 네트워크 통신에 많은 데이터를 처리한다면 성능 향상에 큰 도움이 될 수 있다.

## 2. Lists

key-value에서 value에 하나의 값이 아닌 여러개의 값이 집합으로 들어가있는 형태

### Lists 요약

- Linked-list 형태의 자료구조(인덱스 접근은 느리지만 데이터 추가/삭제가 빠르다)
- queue와 stack으로 사용할 수 있다.
- 앞쪽으로 넣고 앞에서 빼면 스택, 앞으로 넣고 뒤에서 빼면 큐

![스크린샷 2023-03-26 오후 12.14.22.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.14.22.png)

![스크린샷 2023-03-26 오후 12.13.48.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.13.48.png)

## 3. Sets

### Sets 요약

- 순서가 없는 유니크한 값의 집합(특정 값이 set에 포함되어있는지 아닌지를 빠르게 구하기 용이)
- 검색이 빠름
- 개별 접근을 위한 인덱스가 존재하지 않고 집합연산이 가능하다.(교집합, 합집합 등)
- 개별 값에 대한 존재 여부를 빠르게 체크하는 특성으로 활용할 수 있는 서비스
    - 유저가 쿠폰을 받았는지 여부를 체크할 때

![스크린샷 2023-03-26 오후 12.30.24.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.30.24.png)

## 4. Hashes

### Hashes 요약

- 하나의 key 안에 여러개의 필드 그리고 필드의 값을 저장할 수 있는 자료구조(feild-value 쌍을 저장)
- 여러 필드를 가진 객체를 저장하는 것으로 생각할 수 있다. (스트링도 가능, json 오브젝트로 만들거나해서)
- 스트링 json으로 객체 표현하는 것과의 차이점은 필드의 일부에만 접근하고 싶을때도 전체를 불러오고 파싱해야한다. 하지만, 해시는 특정 필드를 지정해서 값을 가져올 수 있기 때문에 필드 각각에 대한 접근성이 좋다. 필드 전체에 대한 값을 한번에 불러올때는 스트링으로 저장하는 것이 용이.
- ⇒ 카운터로 활용 가능하다.(HINCRBY 명령어를 사용해서) 유저가 가지는 필드에 대한 값을 각각 변경해야할때

![스크린샷 2023-03-26 오후 4.03.26.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.03.26.png)

![스크린샷 2023-03-26 오후 4.10.35.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.10.35.png)

- hkeys : 특정 키의 모든 필드들을 보여준다.

## 5. SortedSets

### Sorted Sets 요약

- set과 유사하게 유니크한 값의 집합을 표현
- 각 값들이 연관된 score라는 데이터를 추가로 가지고 있고 정렬되어 있다.
- 정렬된 상태이기에 빠르게 최소/최대값을 구할 수 있다.
- 순위 계산, 리더보드 구현 등에 활용된다.

![스크린샷 2023-03-26 오후 4.19.14.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.19.14.png)

![스크린샷 2023-03-26 오후 4.22.29.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.22.29.png)

## 6. Bitmaps

### Bitmaps 요약

- 비트 벡터를 사용해 N개의 set을 공간 효율적으로 저장
- 하나의 비트맵이 가지는 공간은 (2^32-1) ⇒ 4바이트
- 예를 들어, 특정일에 유저들의 방문 현황을 저장할 때 인덱스를 유저번호로 하고 각 유저가 방문했을 경우 1로 바꾸면 42억명 유저의 방문현황을 저장할 수 있다.
- 비트 연산 가능.

![스크린샷 2023-03-26 오후 4.42.48.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.42.48.png)

![스크린샷 2023-03-26 오후 4.46.33.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.46.33.png)

## 7. HyperLogLog

### HyperLogLog 요약

- 값들을 넣은 다음에 그 값들이 유니크한 값으로 나눴을 때 총 몇개인지를 알아내는 용도로 사용
- bitcount와 비슷한 용도를 가지지만, 효율성이 더 좋다.
- 확률적 자료구조(100% 정확한 값을 보장하지 않는다.) 로서 오차가 있으며, 매우 큰 데이터를 다룰 때 사용.
- 약간의 정확도를 포기함으로써 더 큰 효율성을 얻는다.
- 2^64개의 유니크 값을 계산 가능
- 12KB까지 메모리를 사용하며 0.81%의 오차율을 허용한다.
- bitmap은 인덱스를 사용해서 유저 id같은 숫자에 매핑시켜야 했다. 하지만, hyperloglog는 어떤 문자열이든 사용할 수 있기 때문에, 이름이나 브라우저 id, 하드웨어 id 등 여러가지 모양을 가진 string을 사용할 수 있다. ⇒자유도가 높다.
- 값을 넣을 때 내부에 데이터를 저장하지 않는다.

![스크린샷 2023-03-26 오후 4.57.54.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.57.54.png)

![스크린샷 2023-03-26 오후 5.01.15.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.01.15.png)

# 5. Redis 개발 실습

## 02. Redis 연동 개발

### Redis 라이브러리 사용

- Lettuce : 가장 많이 사용되는 라이브러리로, Spring Data Redis에 내장되어 있다.
- Spring Data Redis는 RedisTemplate이라는 Redis 조작의 추상 레이어를 제공한다.
    - 추상 레이어를 제공하기에 내장된 lettuce가 다른 라이브러리로 변경되어도 우리 코드는 수정할 필요가 없다. (추상 레이어의 장점)
    - RedisTemplate를 사용하면 자바에서 제공되는 자료구조(스트링, 리스트, 해쉬 등)를 redis 자료구조랑 매핑해줌으로써 편리하게 redis를 이용할 수 있다.

![스크린샷 2023-03-26 오후 8.10.55.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.10.55.png)

# 6. 분산 환경에서의 세션 스토어 만들기

## 01. 세션이란?

### 세션

- 네트워크 상에서 두 개 이상의 통신장치간에 유지되는 상호 연결
- 연결된 일정 시간 동안 유지되는 정보를 나타낸다.
- 적용 대상에 따라 다른 의미를 가진다. (osi 7 layer에서의 세션 계층, tcp/ip connection에서 3 way-handshake 이후의 연결된 상태, http 계층에서의 세션)

### Web 로그인 세션

네트워크 상에서 다양한 계층의 세션들과는 다른 의미를 가진다. 유저가 로그인한 상태를 식별할 수 있는 상태.

- 웹 상에서 특정 유저가 로그인했음을 나타내는 정보
- 브라우저는 Cookie를, 서버는 해당 Cookie에 연관된 세션 정보를 저장한다.
- 유저가 로그아웃하거나 세션이 만료될 때까지 유지되어 유저에 특정한 서비스가 가능하다.

![스크린샷 2023-03-26 오후 10.03.23.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.03.23.png)

### Web 로그인 과정

![스크린샷 2023-03-29 오후 1.08.12.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_1.08.12.png)

### 분산 환경에서의 세션 처리

- 서버는 세션 정보를 저장하는데 서버가 여러대라면 최초 로그인한 서버가 아닌 서버는 세션 정보를 알지 못한다. ⇒ 서버들이 외부에 저장소를 두고 세션을 공유해야 한다.
- 세션 정보를 서버간에 공유할 방법이 필요하다(세션 클러스터링)

![스크린샷 2023-03-29 오후 1.11.46.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_1.11.46.png)

세션 정보를 어디에 저장해야 할까?

### 분산 환경에서의 세션 처리 - RDB 사용

**RDB가 적합한지 생각해보자**

- 관계형 데이터 모델이 필요한가? ⇒ 세션 데이터는 단순하게 세션 아이디와 유저정보만 있으면 된다.(key-value 형태)
- 영속성이 필요한 데이터 인가? ⇒ 세션 데이터의 생명 주기는 길지가 않다.(1시간 지나면 로그아웃되고..)
- 성능 요구사항을 충족하는가? ⇒ 세션은 모든 요청에 대해 계속 access하게 된다. 요청이 로그인한 유저가 맞는지 확인해야하기때문에 빈번하게 세션 데이터를 확인한다. 그럼 RDB가 부하를 많이 받게된다.

### 분산 환경에서의 세션 처리 - Redis 사용

- 세션 데이터는 단순 key-value 구조( 세션 id와 유저정보)
- 세션 데이터는 영속성이 필요 없다. (세션은 유저가 로그인한 동안만 유지되면 되기 때문에)
- 세션 데이터는 빈번하게 access되기 때문에 빠른 액세스 속도를 제공하는 레디스가 적합하다.

## 2. Spring Boot에서의 세션 관리

### 세션 관리를 위한 서버의 역할

- 세션 생성: 요청이 들어왔을 때 세션이 없다면 만들어서 응답에 set-cookie로 넘겨준다.
- 세션 이용: 요청이 들어왔을 때 세션이 있다면 해당 세션의 데이터를 가져온다.
- 세션 삭제: 타임아웃이나 명시적인 로그아웃 API를 통해 세션을 무효화한다.

**서버는 모든 요청에 대해 쿠키를 파싱해서 확인하는 등 쿠키 관련된 작업을 해야하는데 번거로운 작업이 될 수 있 다. ⇒ 이걸 편하게 해주는게 스프링의 httpSession 인터페이스**

### HttpSession

- 세션을 손쉽게 생성하고 관리할 수 있게 해주는 인터페이스
- UUID로 세션 ID를 생성.
- JSESSIONID라는 이름의 쿠키를 설정해 Http 헤더를 통해 클라이언트한테 전달해 브라우저가 저장한다.
- http세션을 사용함으로써 간편하게 세션을 관리할 수 있다.

![스크린샷 2023-03-29 오후 2.42.20.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.42.20.png)

### 분산 환경에서 세션 ID가 공유되지 않는 문제

서버 인스턴스를 8080 포트와 8081, 두개의 포트로 띄우고

![스크린샷 2023-03-29 오후 3.15.08.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.15.08.png)

![스크린샷 2023-03-29 오후 3.15.23.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.15.23.png)

쿠키는 도메인 별로 사용하는데 포트를 구분하지 않기 때문에 다른 인스턴스로 접근하면 세션ID를 모른다.

![스크린샷 2023-03-29 오후 3.20.23.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.20.23.png)

8080에서 로그인하면 jsessionID를 1로 만든다. 그리고나서 8081에서 1이라는 쿠키로 유저 데이터를 가져오려하면 가져오지 못한다.(8081 서버는 jsessionID=1을 모르기 때문) 그리고 JSESSIONID를 2로 만들어 덮어씌운다. 그리고 다시 8080에서 데이터를 가져오려하면 가져오지 못한다.(8080은 JSESSIONID=2를 모르기 때문)

## 3. Redis를 사용한 세션 클러스터링

![스크린샷 2023-03-29 오후 3.41.56.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.41.56.png)

yml파일에서 spring session storage-type: redis로 설정하면 세션을 레디스에 저장하게 된다.

(의존성도 추가해줘야한다. `implementation 'org.springframework.session:spring-session-data-redis'`)

# 7. 서비스 속도를 높이는 캐시 레이어 만들기

## 1. 캐싱의 원리와 목적

### 캐싱

- 캐시 : 성능 향상을 위해 값을 복사해놓는 임시 기억 장치
- 접근 속도가 느린 장치나 비용이 드는 접근(네트워크를 통한 접근)보다 값싸게 빠르게 데이터를 얻기 위해 사용
- 캐시의 데이터는 원본이 아니며 언제든 사라질 수 있다.
- 복사본이라는 것은 일관성 문제가 생길 수 있어서 신경써야한다.

### 캐시의 적용

![스크린샷 2023-03-29 오후 6.57.44.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.57.44.png)

- 웹브라우저는 스스로 캐시를 이용 : 자주 바뀌지 않는 정적 파일들(이미지, js소스파일)
- 캐시를 사용함으로써의 이점
    - 네트워크를 타는 과정이 없기 때문에 네트워크 지연 감소
    - api 호출을 줄이기 때문에 서버 리소스 사용 감소
    - 트래픽이 늘어남에 따라 디비(일관성을 생각해 rdb)에 부하 증가해서 발생하는 병목현상 감소

### 캐싱 관련 개념들

- 캐시 적중(Cache Hit): 캐시에 접근해 데이터를 발견함
- 캐시 미스(Cache Miss): 캐시에 접근했으나 데이터를 발견하지 못함.
- 캐시 삭제 정책(Eviction Policy): 캐시의 데이터 공간 확보를 위해 저장된 데이터를 삭제하는 알고리즘
- 캐시 전략: 환경에 따라 적합한 캐시 운영 방식을 선택해야 한다.(읽기가 더 많이 일어나거나, 쓰기가 더 많이 일어나거나..에 따라 Cache-Aside, Wirte-Through)

### Cache Aside(Lazy Loading)

- 항상 캐시를 먼저 체크하고, 없으면 원본(DB)에서 읽어온 후에 캐시에 저장한다.
- 가장 일반적인 형태
- 장점: 필요한 데이터만 캐시에 저장되고, 캐시 미스가 있어도 치명적이지 않다.
- 단점: 최초 접근은 느리다, 업데이트 주기가 일정하지 않기 때문에 캐시가 최신 데이터가 아닐 수 있다는 일관성 문제가 있을 수 있다.(캐시가 존재하는 시간을 짧게 해서 만료되게 한다거나 하는 방식으로 해결)

![스크린샷 2023-03-29 오후 7.14.12.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.14.12.png)

### Write-Through

- 데이터를 쓸 때 항상 캐시를 업데이트하여 최신 상태를 유지한다.
- 장점: 캐시가 항상 동기화되어 있어 데이터가 최신이다. (일관성에 대해 고민하지 않아도 된다.)
- 단점: 자주 사용하지 않는 데이터도 캐시되고, 쓰기 지연시간이 증가한다.

![스크린샷 2023-03-29 오후 7.15.29.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.15.29.png)

### Write-Back

- 데이터를 캐시에만 쓰고, 캐시의 데이터를 일정 주기로 DB에 업데이트
- 장점: 쓰기가 많은 경우 DB 부하를 줄일 수 있다.
- 단점: 캐시가 DB에 쓰기 전에 장애가 생기면 데이터 유실 가능.
- 로그 데이터 쓰는 서비스 등에 사용

![스크린샷 2023-03-29 오후 7.20.06.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-29_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.20.06.png)

### 데이터 제거 방식

- 캐시는 데이터 공간이 한정되어 있기 때문에 데이터 제거 방식을 잘 활용해야 한다.
- 캐시에서 어떤 데이터를 언제 제거할 것인가?
- Expiration: 각 데이터에 만료시간(TTL)을 설정해 시간 기반으로 삭제하는 방식
- Eviction Algorithm: 캐시가 가득 찬 상태에서 공간을 확보해야 할 경우 어떤 기존 데이터를 삭제할지 결정하는 방식
    - LRU(Least Recently Used): 가장 오랫동안 사용되지 않은 데이터를 삭제하는 방식.
    - LFU(Least Frequently Used): 가장 적게 사용된 데이터를 삭제하는 방식.(최근에 사용되었더라도)
    - FIFO(First In First Out): 먼저 들어온 데이터를 삭제하는 방식.

## 2. Redis를 사용해 직접 캐싱 만들어보기

### 실습 프로그램 구조

![스크린샷 2023-03-31 오후 2.20.07.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.20.07.png)

## 3. Spring의 캐싱 기능을 활용해 실제 비즈니스 로직 작성

### Spring의 캐시 추상화

- CacheManager를 통해 일반적인 캐시 인터페이스 제공(다양한 캐시 구현체 존재)
- 메소드에 캐시를 손쉽게 적용 가능(어노테이션 붙여서)

![스크린샷 2023-03-31 오후 3.30.35.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.30.35.png)

파라미터를 키값으로 해서 리턴값이 캐싱된다.

![스크린샷 2023-03-31 오후 3.31.21.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.31.21.png)

yml에 spring.cache.type : redis 추가, 메인메소드에 @EnableCaching 추가해서 사용

![스크린샷 2023-03-31 오후 3.33.23.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.33.23.png)

![스크린샷 2023-03-31 오후 3.34.55.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.34.55.png)

캐싱에 대한 세부사항을 컨트롤하려면 CacheManager를 직접 Bean으로 구현해줘야한다.

![스크린샷 2023-03-31 오후 4.01.00.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.01.00.png)

config를 원하는 대로 커스터마이즈 할 수 있다.

## 어떤 캐시 방식을 사용하는 게 더 좋을까?

일반적으로는 스프링 캐시를 사용하는게 더 좋다. 왜냐하면 직접 redisTemplate를 통해 값을 체크하고 set하는 로직을 구현해야하는데 getUserProfile 메소드 안에 캐싱을 위한 코드가 섞이게 된다.(가독성과 코드 응집력이 떨어진다. 한 메소드는 한 기능만 해야하기 때문)  

또한, 리턴타입에 대해서 구현해야할 부분이 줄어들게 된다. redisTemplate을 사용하면 레디스 키의 타입에 따라 비즈니스 로직에서 변환해줘야하는 작업이 생길 수 있다.

# 8. 게임 리더보드 만들기

# 9. Pub/Sub를 이용해 손쉽게 채팅방 기능 구현하기

## 1. Pub-Sub 패턴의 이해

### Pub/Sub 패턴

- 메시징 모델 중의 하나로 발행(Publish)과 구독(Subscribe) 역할로 개념화 한 형태
- 한쪽은 메시지를 발행하고 다른 한쪽은 메시지를 구독해서 수신해가는 형태
- 퍼블리셔가 메시지를 발행하고 나면 특정 주제를 택해서 그 주제 밑으로 메시지가 모이게되고 그 메시지들을 subscriber들이 주제를 구독하고싶거나 메시지를 받고싶으면 자유롭게 받아갈 수 있는 구조
- 발행자와 구독자는 서로 간에 직접적인 연결이 없고 미들웨어를 통해 연결된다.
- 발행자와 구독자는 서로에 대한 정보 없이 특정 주제(토픽 or 채널)를 매개로 송수신한다.

![스크린샷 2023-03-31 오후 4.54.35.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.54.35.png)

### 메시징 미들웨어(메시지큐) 사용의 장점

- 비동기 처리: 기존의 TCP나 HTTP를 이용해서 서버들간의 통신을 처리하면 동기방식을 사용하는데 그렇게되면 메시지를 받을 서버가 항상 떠있어야하고 또한, 메시지가 몰렸을 때 부하분산을 적절히 할 수 없는 단점이 있다. 통신의 비동기 처리를 통해  메시지를 처리되는 시간을 조정할 수 있다.
- 낮은 결합도: 송신자와 수신자가 직접 서로 연결되지 않고 공통 미들웨어에 의존하기 때문에 한쪽이 변경되어도 반대쪽이 영향을 받지 않는다.
- 장애 발생시에 탄력성 : 구성원들간에 느슨한 연결(낮은 결합도)을 가지기 때문에 일부 서버들이 장애가 생겨도 영향이 최소화된다. 메시지 미들웨어를 사용해서 메시지가 오고 가기 때문에 한 서버가 문제가 생기면 그 서버가 메시지를 받지 못하거나 하는 정도의 문제만 있고 다른서버들은 정상 동작.
    - 메시지 미들웨어 자체가 장애가 생기면 문제가 된다. 그런 부분은 분산화를 통해 해결가능.

**메시징 미들웨어 제품들 : Kafka, RabbitMQ, ActiveMQ, …**

### Redis의 Pub/Sub 특징

- 메시지 미들웨어 == 메시지 큐는 메시지를 저장한다는 건데 그래서 비동기 처리를 가능하게 한다.
    - 레디스는 메시지가 큐에 저장되지 않는다. ⇒ 현재 온라인으로 떠 있는 subscriber들에게만 메시지가 전송된다.
- Kafka는 컨슈머 그룹을 제공해서 분산처리를 할 수 있게 한다.(예를 들어, 어떤 토픽의 메시지를 하나 발행하면 그 토픽을 comsume하는 그룹이 있어서 그 그룹에 속한 서버 하나만 가서 메시지를 처리하면 나머지 서버들은 동일한 메세지에 대해 처리하지 않는 구조 ⇒ 부하 분산을 할 수 있다.)
    - 레디스는 Kafka의 컨슈머 그룹같은 분산처리 개념이 없다. (모든 subscriber들에게 메세지를 전송한다.)
- Kafka는 메시지 발행 시에 메세지를 전달하는 방식이 Polling(메시지를 수신하고 싶은 subscriber가 실제 Kafka 서버로 와서 메시지를 받아가는 방식)이다.
    - 레디스는 메시지 발행 시 Push 방식으로 메시지가 들어오는 즉시 subscriber들에게 메시지를 전송한다.
    - 그렇기 때문에 subscriber가 늘어나게 되면 등록된 모든 subscriber에게 메시지를 전송해줘야 하기 때문에 성능저하가 일어날 수 있다.

![스크린샷 2023-03-31 오후 5.14.06.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-31_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.14.06.png)

### Redis Pub/Sub의 유즈케이스

- 실시간으로 빠르게 전송되어야 하는 메시지
- 메시지를 저장할 큐가 존재하지 않기 때문에 메시지가 유실 될 수 있다.
    - 메시지 유실을 감내할 수 있는 케이스(메시지의 라이프 사이클이 짧아야 한다.== 잠시동안만 의미가 있는 데이터)
- 최대 1회 전송 패턴이 적합한 경우
    - 메시지 전달 모델에서 몇 가지 타입이 있는데 그 중 하나(최소 1회 전송(중복메시지가 갈 수 있다.) 등..)
    - 레디스는 중복 메시지는 가지 않고 메시지가 유실되거나 최대 1회 전송이 된다.
- Subscriber들이 채널(구독하는 topic)을 유동적으로 바꾸면서 잠깐동안 구독하는 경우
    - Kafka는 토픽을 유동적으로 생성하기보다는 고정적으로 정해놓고 사용하는 케이스에 적합.

## 2. Redis Pub/Sub을 이용한 채팅방 구현

### 채팅방 기능의 요구사항

- 채팅 클라이언트와 채팅 서버가 존재하고 통신방식(프로토콜)을 정해야 한다.
- 채팅 서버는 채팅방 관리 로직을 작성해야 한다.

![스크린샷 2023-04-01 오후 12.41.11.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.41.11.png)

### Redis Pub/Sub을 이용한 채팅방 구현

- 채팅방 기능을 Publish/Subscribe 구조를 이용해 쉽게 구현

![스크린샷 2023-04-01 오후 12.43.13.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.43.13.png)

- 채팅 서버가 필요 없게 된다.
- 채팅방 생성 ⇒ 채널 사용
- 채팅방 접속자 관리 ⇒ 특정 채널에 메시지를 보내면 그 채널을 subscribe하고 있는 클라이언트들에게 모두 메시지가 전송되기 때문에 필요 없다.
- 채팅방 메시지 수신/전송 ⇒ 레디스 pub/sub에서 제공하는 채널의 메시징 기능이 수행해주기 때문에 필요없다.
- 클라이언트만 구현하면 된다.
- 서비스에 접속한 유저들에게 알람을 보내거나 알려야할 notification 종류의 정보성 메세지를 보내거나 하는 서비스에 적용할 수 있다. 커스텀하게 관심사에 따라 받아보고싶은 알림 종류에 따라 설정할 수도 있다. 유저들뿐만아니라 서버들간의 메세지에도 사용할 수 있다.

# 10. Redis의 백업과 장애 복구

레디스 백업: 인메모리에 들어있는 레디스의 데이터를 디스크에 저장함으로써 휘발성인 데이터가 프로세스가 내려갔다 올라와도 복구되거나 유지될 수 있도록 하는 방법

## 1. RDB를 사용한 백업

### RDB(Redis Database)를 사용한 백업

- 일정 시간마다 전체 데이터를 디스크에 쓰는 방법
- 특정 시점의 스냅샷으로 데이터 저장.
- 재시작 시 RDB 파일이 있으면 읽어서 복구한다.
- 백업 주기는 설정 가능하다.
- 수동으로 명령어를 입력해서 바로 백업 스냅샷을 만들 수 있다.

![스크린샷 2023-04-02 오전 11.52.44.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.52.44.png)

### RDB 사용의 장점

- 작은 파일 사이즈(AOF 대비)로 백업 파일 관리가 용이하다.(원격지 백업, 버전 관리 등) 메모리에 있는 데이터를 그대로 스냅샷으로 저장하기 때문에 부가적인 데이터가 없기 떄문에 작다.
- 파일 사이즈가 작기 때문에 멀리 보내기 용이(예를 들면 aws s3에 저장한다거나)
- 스냅샷이 떠진 시간 별로 저장되기 때문에 버전관리 용이
- RDB 스냅샷이 떠질 때 방식은 실제 서비스 하고 있는 프로세스(부모 프로세스)에서 fork를 이용해 child process를 만들고 child process가 RDB 파일의 스냅샷 저장을 하기 때문에 부모 프로세스는 서비스를 계속 할 수 있어 성능에 영향이 없다.
- 데이터 스냅샷 방식이므로 복구 방식이 단순하고 빠르다. 파일에 저장된 데이터를 그대로 메모리에 올리기만 하면 복구가 되기 때문에

### RDB 사용의 단점

- 스냅샷을 저장하는 시점 사이의 데이터 변경사항은 유실될 수 있다.
- fork를 이용하기 때문에 시간이 오래 걸릴 수 있고, CPU와 메모리 자원을 많이 소모한다.
- 데이터 무결성이나 정합성에 대한 요구가 크지 않은 경우 사용 가능하다.

### RDB 설정

- 설정파일이 없어도 기본값으로 RDB가 활성화되어 있다. (일정 주기로 저장하게 되어있다.)
- 설정 파일은 템플릿을 받아서 사용하는게 편하다(레디스 공식문서에서 참고)
- 실무에서는 bgsave 사용을 권장한다. 왜냐하면 스케줄 기반으로 스냅샷을 뜨다보면 예측할 수 없는 상황이 많이 생기기도 하고 또, 데이터가 너무 많은데 잦은 주기로 백업을 해서 스냅샷 자체에 걸리는 시간이 많아지기 때문에 부하가 발생하기 때문이다.

![스크린샷 2023-04-02 오후 12.07.20.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.07.20.png)

### Docker를 사용해 Redis 설정 파일 적용하기

- Docker run 사용시 -v 옵션을 이용해 디렉토리 또는 파일을 마운팅할 수 있다.
- redis 이미지 실행 시 redis-server 명령어 뒤에 직접 redis 설정파일 경로를 입력해서 특정 설정파일을 읽어서 가동되도록 지정할 수 있다.

![스크린샷 2023-04-02 오후 12.16.45.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_12.16.45.png)

## 2. AOF를 사용한 백업

### AOF(Append Only File)를 사용한 백업

- AOF는 로깅의 특성을 가지고 파일이 수정되지 않고 계속 내용을 덧붙여나가는 방식의 데이터 관리 유형이다.
- 모든 쓰기 요청이 들어올때마다 레디스의 변경사항이 생길때마다 하나하나의 명령어에 대해 전부 기록한다.
- 모든 명령어의 히스토리가 저장되고 레디스가 재시작 될 때 aof파일에 기록된 모든 operation을 재실행한다.

![스크린샷 2023-04-02 오후 2.53.54.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.53.54.png)

### AOF 사용의 장점

- 모든 변경사항이 기록되므로 RDB 방식 대비 안정적으로 데이터 백업 가능하다.
- AOF 파일은 append-only 방식(뒤에 덧붙이기만 하는 방식)이므로 백업 파일이 손상될 위험이 적다.
- 실제 수행된 명령어가 저장되어 있으므로 사람이 보고 이해할 수 있고 수정도 가능하다.

![스크린샷 2023-04-02 오후 2.56.54.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.56.54.png)

### AOF 사용의 단점

- RDB 방식보다 파일 사이즈가 커진다. RDB는 메모리에 있는 스냅샷을 그대로 뜨기 때문에 원래 메모리를 차지해야할 정도의 사이즈만 생성되는 반면 AOF는 히스토리를 전부 저장하기 때문에 실제 최종적으로 메모리에 유지되는 데이터 사이즈와는 상관없이 그동안 수행된 명령어가 많으면 더 큰 파일이 생성되기 때문이다.
- RDB 방식 대비 백업이나 복구 속도가 느리다.(파일 사이즈 크기 문제) 백업 성능은 실제 디스크에 저장하는 fsync 정책에 따라 조절 가능하다.(그래도 rdb보다는 좀 느리다.) 복구 속도도 모든 커맨드를 리플레이 하는 방식으로 하기 때문에 rdb의 스냅샷에 비해 느리다. (스냅샷은 그대로 가져와서 메모리에 넣으면 되기 때문)

### AOF 설정

![스크린샷 2023-04-02 오후 3.03.28.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.03.28.png)

### fsync 정책(appendfsync 설정 값)

- fsync() 호출은 OS에게 데이터를 즉시 디스크에 써달라고 요청하는 것.
- 이게 왜 필요한가 하면 디스크에 있는 파일에 데이터를 쓴다고해도 실제 디스크에 바로 저장되는게 아니다. OS가 중간에서 적절한 타이밍에 데이터를 쓰게 되고 그 사이에는 일종의 버퍼링 과정을 거칠 수 있다. 완전한 실시간은 아니라는 것. 이게 OS마다 다르기 때문에 이걸 강제해서 옵션을 줄 수가 있다.
- 가능한 옵션
    - always: 새로운 커맨드가 추가될 때마다 수행해서 디스크에 확실히 저장되게 한다. 디스크의 write는 비용이 비싼 작업이기 때문에 성능상의 문제가 많다. 가장 안전하지만 가장 느리다. 너무 느려서 레디스 장점(빠른 속도)이 무색해질 정도.
    - everysec:  1초마다 수행. 성능은 RDB가 fork 사용해서 스냅샷을 뜨는 수준에 근접. 일반적으로 많이 사용.
    - no: OS에 맡기는 방법. OS 커널마다 구현이 달라질 수 있어 언제 저장될지 불확실하다. OS가 필요에 따라 적절하게 시간을 결정하기 때문에 효율적으로 데이터를 다룰 수 있다. 가장 빠르지만 덜 안전한 방법.

### AOF 관련 개념

- log rewriting: 수동으로 실행할 수도 있고 설정파일을 통해 일정주기로 실행되게 할 수도 있다. 너무 많아진 AOF 파일의 내용을 줄이기 위해 사용. 최종 상태를 만들기 위한 최소한의 로그만 남기기 위해 일부를 새로 쓴다. (예를 들어 1개의 key값을 100번 수정해도 최종 상태는 1개이므로 set 1개로 대체 가능)
- multi part AOF: 레디스 7.0부터 AOF가 단일 파일에 저장되지 않고 여러개가 사용된다. aof 파일을 안정적으로 관리하기 위해.
    - base file: 마지막 rewrite(log-rewriting의 결과) 시의 스냅샷을 저장.
    - incremental file: 마지막으로 base file이 생성된 이후의 변경사항이 쌓인다. 이후에 rewriting이 다시 일어나게 되면 여기에 작성된 변경사항들이 base file로 이동.
    - manifest file: 파일들을 관리, 추적하기 위한 메타 데이터를 저장.

## 3. Redis의 복제

백업 파일 만으로 장애 대응에 있어서 미흡한 부분이 있다. 추가적으로 복제 메커니즘을 이용해 가용성을 향상시킬 수 있다.

### Redis replication(복제)

- 백업만으로는 장애 대비에 부족하다.(백업 실패 가능성, 복구에 소요되는 시간)
- redis는 복제 노드를 추가로 두어 가용성을 확보하고 빠른 장애조치가 가능한다.
- 복제 노드를 두었다가 master에 문제가 생겼을 때 복제 노드 중 하나를 마스터로 전환해(마스터로 승격) 빠르게 장애를 조치하는 방법. 즉시 서비스 정상화가 가능하다.
- 복제 노드는 여러개 존재할 수 있고 복제본의 복제본도 존재할 수 있다.
- 복제 노드들은 데이터를 동일하게 가지고 있기 때문에 read-only로 접근하게 해 traffic을 마스터로부터 분산할 수 있다.

![스크린샷 2023-04-02 오후 3.52.55.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.52.55.png)

### Redis 복제 사용

- Replica 노드에서만 설정을 적용할 수 있다. 설정하면 master-replica 복제 구성 가능

![스크린샷 2023-04-02 오후 3.55.08.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_3.55.08.png)

- replicaof 설정값에 마스터의 ip와 port를 지정하면 바로 replication 모드로 동작한다.
- **replica를 활성화 했을 때 마스터 노드는 RDB나 AOF를 이용해 백업 기능을 활성화가 필수다. 마스터가 장애로 인해 재시작 되었을 때 데이터가 다 날아갔는데 복제 노드들은 온전한 데이터가 남아있는데도 불구하고 마스터의 빈 데이터들을 복제해서 마스터만 장애가 생겼는데도 복제 노드들도 데이터가 날아가는 결과가 생긴다.**

### Docker-Compose

- 여러 개의 컨테이너로 구성된 어플리케이션을 정의하고 실행할 수 있는 도구
- 여러 개의 컨테이너를 띄우고 싶을 때 한 파일로 정의를 해놓고 실행하면 정의되어있는 여러 컨테이너들이 한번에 뜰 수 있도록 해준다.
- YAML 파일을 통해 설정
- docker-compose up 명령어로 실행
    - -d 옵션은 백그라운드 실행
    - —build 옵션은 이미지 빌드 후 compose up 하는 것
        - —build 옵션을 주면 캐싱된 이미지를 체크하지 않고 무조건 빌드하고 시작한다. 붙이지 않아도 이미지에 없으면 빌드부터 한다. 소스 수정이 이루어졌을 때는 다시 이미지를 빌드해야하므로 가급적 —build 옵션을 붙이자.

![스크린샷 2023-04-02 오후 5.14.52.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.14.52.png)

docker-compse.yml

```java
version: "3"
services:
	my-redis-a:
		hostname: redis-master
		container_name: redis-master
		image: "bitnami/redis"
		environment:
			- REDIS_REPLICATION_MODE=master
			- ALLOW_EMPTY_PASSWORD=yes
		ports:
			- 5000:6379
	my-redis-b:
		hostname: redis-replicas-1
		container_name: redis-replicas-1
		image: "bitnami/redis"
		environment:
			- REDIS_REPLICATION_MODE=slave
			- REDIS_MASTER_HOST=redis-master
			- ALLOW_EMPTY_PASSWORD=yes
		ports:
			- 5001:6379
		depends_on:
			- my-redis-a
```

- bitnami/redis : bitnami에서 배포하는 이미지들은 좀 더 다양한 환경에 설치하고 쉽게 환경설정 할 수 있도록 기능이 추가된 것들.
- redis.conf를 수정하지 않고 replication 모드로 돌아가게 설정할 수 있도록 environment에 redis-replication-mode 사용
- master,slave가 연결될 수 있도록 empty-password 허용
- depends-on: my-redis-a라는 서비스가 먼저 수행되어야 한다는 뜻. 마스터 역할을 하는 my-redis-a가 먼저 뜬 다음에 my-reids-b가 떠서 replica가 동작할 수 있도록 구성.

## 2. Redis Sentinel을 이용한 자동 장애조치

레디스 복제를 사용하면 rdb나 aof를 파일을 이용해 백업했다가 복구하는 것보다는 훨씬 빠르게 장애 복구를 할 수 있지만 마스터를 바꾸는 작업을 수동으로 해줘야 하는 아쉬운 점이 있다. 그런 부분을 자동으로 해주는 redis sentinel에 대해 알아보자.

### Redis Sentinel

- Redis에서 HA(high availability)를 제공하기 위한 장치
- master-replica 구조에서 모두 모니터링 하고 있다가 마스터에 장애 발생 시 replica중 하나를 master로 승격시키는 auto-failover를 수행한다.
- 센티넬을 사용하게 되면 클라이언트가 센티넬을 통해 레디스 노드에 붙게 된다. 왜냐하면 마스터가 바뀔 수 있기 때문이다.

![스크린샷 2023-04-02 오후 8.50.14.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.50.14.png)

### Redis Sentinel 실제 구성도

![스크린샷 2023-04-02 오후 8.51.47.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.51.47.png)

- 센티넬이 여러대로 구성된다. 여러대가 있는 이유는 센티넬이 마스터가 다운됐다는 판단을 내릴 때 일정 수 이상의 정족수를 맞춰야만 공식적으로 판단이 내려지기 때문에.(Quorum)
- 센티넬끼리 연결되어 있다가 모니터링 하던 마스터가 내려갔을 때 각자의 판단을 공표한다. 그래서 과반수 이상이 마스터가 다운됐다고 판단하면 진짜 다운됐다고 판단.
- 이러한 매커니즘을 가지는 이유는 센티넬 일부가 네트워크 문제가 있거나 다른 장애로 인해 잘못된 판단을 내릴 수 있기 때문이다.

### Redis Sentinel 특징

- SDOWN(Subjective down)과 ODOWN(Objective down)의 2가지 판단이 있다.
    - SDOWN: Sentinel 1대가 개별적으로 마스터가 down됐다고 판단(주관적)
    - ODOWN: 센티넬들간의 통신에서 실제로 정족수가 충족되어 마스터가 down됐다고 판단(객관적)
- ODOWN이 발생해야 fail-over가 일어난다. (마스터 노드가 down된걸로 판단되기 위해서는 sentinel 노드들이 정족수(Quorum)을 충족해야한다.
- 클라이언트는 sentinel을 통해 master의 주소를 얻어내야한다. (스프링에서 접속할때 센티넬들의 주소로 접속해야한다)
    - 
        
        ![스크린샷 2023-04-02 오후 10.12.53.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.12.53.png)
        

### 센티넬 장애처리 방법

1. 센티넬 서버는 매 1초마다 HeartBeat를 통해 Master 서버와 Slave 서버가 작동 중인지 여부를 확인한다. 만약, 일정 타임아웃동안 응답이 없으면 장애가 발생한 것으로 간주하는데 이를 주관적 다운이라하며 로그파일에 “sdown”으로 표기된다. 이떄 타임아웃 시간은 sentinel.conf 파일에 정의되어 있는 down-after-milliseconds 파라미터에 의해 결정되며 기본 값은 3000Millisecond다.
2. 주관적 다운은 하나의 센티넬 서버가 장애 상태를 인지한 경우이며 만약 센티넬 서버가 여러 대인 경우 모든 센티넬 서버가 여러대인 경우 모든 센티넬 서버가 장애 상태를 인지하면 객관적 다운(Objectively Down)이라고 하며 로그에 ODOWN으로 표기된다. 센티넬 서버는 마스터 서버가 다운된 경우 다른 센티넬 서버와 함께 전체 정족수를 확인하고 최종적으로 마스터가 실제 다운되었다고 판단한다.
3. 주관적 다운과 객관적 다운이 최종 확인되면 장애조치 작업을 단계별로 수행한다
    1. 여러 대의 센티넬 서버로 구축되어 있는 경우 센티넬 리더를 선출해야 하는데 이를 위해 내부에서는 선출과정이 반복적으로 수행되고 최종 센티넬 리더가 선출된다.
    2. 리더로 결정된 센티넬 서버는 장애가 발생한 Master 서버를 대신할 Slave서버를 선정한다.
    3. 선정된 Slave 서버는 최종 마스터 서버로 승격된다.
    4. 남은 Slave 서버가 새로운 Master 서버를 모니터링 하도록 명령을 수행한다.
    5. 모든 작업이 완료되면 센티넬 서버 정보를 갱신하고 장애 복구 작업을 종료합니다.

### Docker-Compose

```
version: "3"
services: 
  my-redis-a:
    hostname: redis-master
    container_name: redis-master
    image: "bitnami/redis"
    environment:
      - REDIS_REPLICATION_MODE=master
      - ALLOW_EMPTY_PASSWORD=yes
    ports:
      - 5000:6379 
  my-redis-b:
    hostname: redis-replicas-1
    container_name: redis-replicas-1
    image: "bitnami/redis"
    environment:
      - REDIS_REPLICATION_MODE=slave
      - REDIS_MASTER_HOST=redis-master
      - ALLOW_EMPTY_PASSWORD=yes
    ports:
      - 5001:6379
    depends_on:
      - my-redis-a

  redis-sentinel-1:
    container_name: sentinel1
    image: 'bitnami/redis-sentinel:latest'
    environment:
      - REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS=3000
      - REDIS_MASTER_HOST=redis-master
      - REDIS_MASTER_PORT_NUMBER=6379
      - REDIS_MASTER_SET=mymaster
      - REDIS_SENTINEL_QUORUM=2
    ports:
      - 26379:26379
    depends_on:
      - my-redis-a
      - my-redis-b
  redis-sentinel-2:
    container_name: sentinel2
    image: 'bitnami/redis-sentinel:latest'
    environment:
      - REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS=3000
      - REDIS_MASTER_HOST=redis-master
      - REDIS_MASTER_PORT_NUMBER=6379
      - REDIS_MASTER_SET=mymaster
      - REDIS_SENTINEL_QUORUM=2
    ports:
      - 26380:26379
    depends_on:
      - my-redis-a
      - my-redis-b
  redis-sentinel-3:
    container_name: sentinel3
    image: 'bitnami/redis-sentinel:latest'
    environment:
      - REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS=3000
      - REDIS_MASTER_HOST=redis-master
      - REDIS_MASTER_PORT_NUMBER=6379
      - REDIS_MASTER_SET=mymaster
      - REDIS_SENTINEL_QUORUM=2
    ports:
      - 26381:26379
    depends_on:
      - my-redis-a
      - my-redis-b
```

- environment의 redis_sentinel_down_after_milliseconds: 몇초의 응답이 없으면 마스터를 다운으로 판단할 것인가에 대한 설정
- redis_master_set: 마스터의 이름 작성, mymaster로 디폴트로 지정되어있다.
- redis_sentinel_quorum: 정족수 지정
- 정족수 지정때문에 센티넬 노드는 홀수로 지정한다.
- 레디스 센티넬들은 실제 레디스 노드가 뜬 이후에 돌아가야하기 때문에 depends_on에 master,replica 노드 작성

센티넬 컨테이너에 접속하고 redis-cli로 클라이언트 접속을 하는데 redis-cli 옆에 -p옵션으로 포트지정을 해줘야한다. 왜냐하면 센티넬은 6379포트를 사용하는 레디스 이미지가 도는게 아니라 레디스 센티넬이 돌기 때문에 26379포트로 접속해야한다.

![스크린샷 2023-04-02 오후 9.27.11.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.27.11.png)

![스크린샷 2023-04-02 오후 9.27.54.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.27.54.png)

# 11. 안정성과 가용성을 위한 클러스터

## 1. 확장성과 분산

### 확장성이란?

- 소프트웨어 서비스의 요구사항 수준이 증가할 때 대응할 수 있는 능력
- 주로 규모에 대한 확장성을 뜻한다.(데이터 크기, 요청 트래픽 등)
- 수직 확장(scale-up)과 수평 확장(scale-out)이 사용된다.

![스크린샷 2023-04-05 오후 7.37.27.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.37.27.png)

### 수평 확장(Scale-out)

- 처리 요소(ex: 서버)를 여러개 두어 작업을 분산
- 무중단 확장이 가능하다.
- 이론적으로는 무한대로 확장이 가능하다.

### 분산 시스템에 따라오는 문제

- 부분 장애(여러개의 노드 중에 일부만 장애가 났을 때 어떻게 처리할 것인가?)
- 네트워크 실패(분산시스템은 네트워크를 통해 연결되어 있다. 하지만 네트워크는 신뢰할 만한 요소가 아니다. 지연이 발생할 수 있고 예상치 못한 실패가 발생할 수 있다. 예상치 못한 실패는 항상 발생한다고 가정하고 개발하는게 좋은 태도. 실제로 네트워크 문제는 자주 생기기 때문)
- 데이터 동기화(데이터 동기화가 100%를 보장하지 않는다. 성능 문제와 trade-off관계이기 때문.)
- 로드밸런싱(클라이언트 요청을 여러개의 노드 중 누가 처리해야하는지 결정해야한다.)
- 개발 및 관리의 복잡성

### 분산 시스템의 적용

- 분산 시스템으로 인한 trade-off를 판단해서 적합하다면 사용
- 서비스 복잡도와 규모의 증가로 분산은 피할 수 없는 선택이 되었다.
- 분산 시스템의 구현체들은 다양한 옵션을 제공해 튜닝이 가능하다.(성능과 데이터 일관성 사이에서 어느정도 수준으로 어떤 특성을 더 보장할지 조절 가능)

## 2. 레디스 클러스터 소개

### 레디스 클러스터란?

- 레디스 클러스터가 제공하는 것
    - 여러 노드에 자동적인 데이터 분산
    - 일부 노드의 실패나 통신 단절에도 계속 작동하는 가용성
    - 고성능을 보장하면서 선형 확장성 제공

### 레디스 클러스터 특징

- full-mesh 구조(모든 노드가 모든 노드에게 연결된 구조)로 통신
- 각 노드들은 cluster bus라는 추가 채널(port)을 사용해서 통신한다.
    - 보통 기본적으로 사용하는 6379포트에 10000을 더한 16379를 클러스터 버스로 사용하게 된다.
- gossip protocol 사용
    - full-mesh 구조에서 클러스터를 유지하기 위한 정보를 주고받는데 만약 모든 노드가 모든 노드에게 정보를 주고 받으면 부하가 상당할 것이다. 그리고 중복된 정보가 많이 오고 갈 것이다.
    - gossip protocol은 너무 많은 노드가 서로 통신을 할 때 통신 갯수를 줄이기 위한 것. 소문이 퍼지는 듯한 모양. 노드 한개는 근처 몇개의 노드랑만 통신을 하게 되면 계산 상 어느정도 시간안에 모든 노드에 퍼지게 된다는 원리로 사용된다.
- hash slot을 사용한 키 관리
    - 어떤 데이터를 노드에 분산시킬 때 어떤 기준으로 분산시킬지 정할 때 보통 분산시스템은 해싱을 사용해 키를 가지고 키 별로 어떤 노드에 들어갈지 선택하게 된다.
- DB0만 사용 가능하다.
    - 레디스는 인스턴스 하나에서도 db를 여러개로 나누어 쓸 수 있는데 클러스터 모드에서는 1개만 사용가능하다.
- 멀티 키 명령어가 제한된다.
    - 클러스터 모드는 데이터가 분산되어있기 때문에 키가 여러개 들어가는 멀티 키 명령이 제한된다.
- 클라이언트는 모든 노드에 접속해야한다.

![스크린샷 2023-04-05 오후 7.59.20.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_7.59.20.png)

### Sentinel과의 차이점

- 클러스터는 데이터 분산(샤딩)을 제공한다.
- 클러스터는 자동 장애조치를 위한 모니터링 노드(센티넬 노드)를 추가 배치할 필요가 없다.
- 클러스터에서는 멀티 키 명령이 제한된다.
    - 센티넬은 싱글 마스터로 동작하게 되어있다. 그래서 싱글 마스터에서는 멀티키 명령에 대한 제약이 없기 때문에 사용 가능하다.
- 센티넬은 비교적 단순하고 소규모의 시스템에서 HA(고가용성)이 필요할 때 채택
- 클러스터가 무조건 센티넬보다 좋아보이지만 어떤 서비스에서는 멀티키 명령이 필요할 수 있다. 하지만 이런 경우를 제외하고는 보통 클러스터가 더 발전된 형태로 볼 수 있다. 데이터 분산과 복제, 고가용성은 보통 같이 묶여다니는 개념이고 분산은 요즘 서비스에서 필연적인 기능이기 때문.

## 3. 데이터 분산과 key 관리

분산시스템에선 데이터 분산에 대한 방법을 결정해야한다.

### 데이터를 분산하는 기준

- 특정 키의 데이터가 어느 노드(샤드)에 속할 것인지 결정하는 매커니즘이 있어야한다.
- 보통 분산시스템에선 해싱이 사용된다.
- 단순 해싱으로는 노드의 개수가 변할 때 모든 매핑이 새로 계산되어야하는 문제가 있다.
- 노드의 개수가 변할 때 나머지 노드들에 영향이 최소한으로 가게하는 방법이 필요하다.

![스크린샷 2023-04-05 오후 8.08.19.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.08.19.png)

### Hash Slot을 이용한 데이터 분산

- 특정 키를 해시 슬롯에 매핑시키고 해시 슬롯을 각 노드에 배분하는 방식
- 레디스는 16384개의 해시 슬롯으로 키 공간을 나누어 관리한다.
- 각 키는 CRC16 해싱 후 16384로 나누어 각 해시 슬롯에 매핑된다.
- 해시 슬롯은 각 노드들에게 나누어 분배된다.
- 노드가 추가되어도 변경이 적다.

![스크린샷 2023-04-05 오후 8.12.49.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.12.49.png)

### 클라이언트의 데이터 접근

- 클라이언트는 클러스터의 모든 노드에 붙어있어야한다.
- 클러스터 노드는 요청이 온 key의 slot에 해당하는 노드로 자동으로 redirect를 해주지는 않는다. (자기가 아니라면 moved에러를 준다.)
- 클라이언트는 moved 에러를 받으면 해당 노드로 다시 요청해야 한다.
- moved 에러에는 키가 해당하는 slot과 그 slot을 서빙하는 노드의 주소를 알려준다.
- 비효울적으로 보일 수 있지만 클라이언트의 요청 재시도가 일어나는 경우는 많지 않다. 왜냐하면 클라이언트가 키값과 노드의 매핑 테이블을 캐싱하고 있기 때문. 한번 매핑 테이블을 만들어 놓으면 잘 변하지 않고 장애가 발생했거나 노드 수가 추가 삭제 되었을 때만 매핑테이블을 업데이트 하게 된다.

![스크린샷 2023-04-05 오후 8.16.55.png](Redis%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8B%E1%85%B4%20aa1f209d9d8849ce86cb8b15abdadc62/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-04-05_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.16.55.png)

## 4. 성능과 가용성

### 클러스터를 사용할 때의 성능

- 

## 레디스 클러스터 HeartBeat 체크 방법

[http://redisgate.kr/redis/cluster/cluster_heartbeat.php](http://redisgate.kr/redis/cluster/cluster_heartbeat.php)
