# Redis

[우아한테크 세미나 (우아한레디스)](https://www.notion.so/be3fef32e9a9481abd914f1cdc6dd899)


# 대용량 처리 관련 기술

- 오픈 소스 소프트웨어
- 디스크가 아닌 메모리 기반 데이터 저장소(인메모리 디비)
- NoSQL & Cache 솔루션
- 명시적으로 삭제, Expire 설정하지 않으면 데이터는 삭제되지 않는다.(=영구적 보존)
- 여러대의 서버 구성 가능
- 데이터베이스로 사용될 수 있으며 캐시로도 사용될 수 있다.
- 성능은 서버에 따라 다르나 초당 2만~10만회 수행
- 키-값 저장소(Key-Value)
- 싱글 쓰레드로 구성되어 있다. 때문에 하나의 인스턴스에서 병렬 처리를 진행할 수 없다. 단, AOF가 동작할 때는 더블-스레드로 동작한다.
- Redis Cluster 구성하는 방법, Sentinel을 구성하는 방법을 통해 고가용성을 제공한다.

## 인메모리 캐시란

서비스 요청이 증가하여 디비 요청이 많아지면 디비서버 부하가 증가하게 된다. 이 때 메모리 캐시가 적용되면 성능 및 처리 속도가 향상된다. 캐시 방식을 통해 디비 조회의 부하를 감소시킬 수 있다.

속도가 빠르지만 비싸다는 단점이 있다. 대략 20배정도 비싸다. 성능이 중요할 때 사용. 적은 데이터가 빈번하게 접근할 때 유용하다. ⇒ 특정 데이터만 접근성이 높을 때.

반대로 여러 데이터가 조금씨 다 접근하면 캐시의 효용성이 떨어진다.

- 성능은 Memcached이 갖고 있는 좋은점을 기반으로 만들어졌기 때문에 Memcached보다 우수하지만 더욱 복잡하다. 그렇지만 다양한 데이터 구조체를 지원한다.(메시지 큐, Shared memory, Remote Dictionary)
- 안전한 데이터의 보관과 백업을 위해 두 가지 방법을 제공한다.
    - 다른 서버의 메모리에 실시간으로 복사본을 저장하는 방법
    - 디스크에 직접 저장하는 방법
- NoSQL 중에서도 Redis가 주목받는 이유
    - 데이터 저장소로 입출력이 가장 빠른 메모리를 채택
    - 단순한 구조의 데이터 모델이 키-값 방식을 통한 빠른 속도
    - 캐시 및 데이터 스토어에 유리
    - 다양한 API 지원
- Redis는 대형 서비스 업체들이 사용자들의 대규모 메세지를 실시간으로 처리하기 위해 사용하고 있다.

## Memcached와 Redis의 차이

![스크린샷 2023-01-01 오후 4.58.54.png](/image/Redis%202080d6d470524efbb3e6cc01a29a42c2/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.58.54.png)

### **Redis**

많은 자료구조(collection) 제공 (컬렉션 중요성 설명)

Replication을 제공해서 더 서비스를 안정적으로 제공

Cluster 모드 제공

### **Memcached**

Redis에 비해 메모리 관리가 더 안정적이다.

Replication 제공 x, Cluster 모드 제공 x

Redis는 메모리 파편화가 일어날 수 있는데 Memcached는 거의 일어나지 않음

Redis는 jemalloc을 써서 실제 메모리 관리를 jemalloc이 한다. 반면 Memcached는 자체적으로 청크를 관리해서 메모리 관리를 좀 더 효과적으로 처리한다.

단순하게 비교하면 Memcached는 캐시 솔루션이다. 이러한 Memcached에 저장소의 개념이 추가된 것이 Redis라고 할 수 있다. 캐시는 빠른 속도를 위해서 어떤 결과를 저장해 두는 것을 의미하며 또한 데이터가 사라지면 다시 만들 수 있다는 전제를 내포하고 있다. 캐시 기능만을 고려한다면 디스크에서 불러오기만 하면 된다. (=Load 기능만 수행하면 된다.) 그런데 저장소라는 개념이 추가되면 데이터가 유지되어야 한다는 특성을 가지게 된다.(=Save 기능도 필요하다)

메모리가 날라가도 원본 데이터로 즉시 복구할 수 있는 데이터는 Memcached를 사용하는 편이 좋을 수 있다. 

메모리가 날아가면 서비스 장애가 발생할 수 있는 상황이라면 Redis를 사용하는 편이 좋을 수 있다. 

통신 속도를 향상시키기 위한 목적이라면 Memcached를 사용하는 게 좋다. 그러나 서비스의 특정 기능을 위한 목적으로 캐시 데이터를 사용한다면 Redis를 사용하는 게 좋다.

## Redis 사용처

- 주로 cache를 저장하기 위한 저장소로 사용
    
    예) look aside cache
    
    어떤 api를 호출할때 api의 결과를 key에 맞춰 저장한다던지, 유저 정보를 저장한다던지
    
- 특수한 케이스는 db 자체를 redis 사용
    
    백업 같은 것은 Replication이나 Rdb나 AOF 같은 것으로 스냅샷을 남겨서 이용. Redis는 SQL은 지원하지 않는다.
    
- 국내 대규모 서비스를 제공하는 곳은 전부 사용한다고 생각해도 된다.
- API 응답 캐시
    - 다음을 고민해야 한다.
    - 캐시를 해도 되는 API인가?
    - key를 어떻게 정의할 것인가?
    - value는 어떻게 정의할 것인가?
- 서비스의 Access Token 저장
    - 서비스에서 매번 로그인하는 것을 피하기 위해 Access Token 사용
    - Access Token은 유효기간이 존재하므로 보안상 탈취당해도 일정시간 이후에는 사용할 수 없다.
    - JWT 같은 경우에는 해당 키가 유용한지 여부만 저장하고 실제 유저 정보는 JWT 안에 저장하는 경우가 많다.
- 요청 수 제한을 위한 Rate Limit
- 랭킹 저장을 위한 랭킹 스코어 보드
- 대규모로 사용하기 위해서 샤딩 또는 consistent hashing등을 통해 데이터를 저장한다.

## Redis 장점

- 리스트, 배열과 같은 데이터를 처리하는데 유용하다.
    - value 값으로 여러 데이터 형식을 지원한다.(String, List, Set, Hash 등)
    - 따라서 다양한 방식으로 데이터를 활용할 수 있다.
    - 리스트형 데이터 입력과 삭제는 MySQL에 비해 10배정도 빠르다고 한다.
- 메모리를 활용하면서 영속적인 데이터 보존이 가능하다.
    - 명령어로 명시적으로 삭제(Expires)를 설정하지 않으면 데이터가 삭제되지 않는다.
    - 디스크에 데이터를 기록하고 있기 때문에 Redis 메모리가 날라가도 데이터를 복구할 수 있다.
    - 스냅샷(기억장치) 기능을 제공하여 메모리의 내용을 *.rdb 파일로 저장하여 해당 시점으로 복구할 수 있다.
    - 스냅샷을 남기는 확장자가 rdb이기 때문에 DB의 모든 기능 역시 지원되지 않을까 생각할 수 있다. 하지만 단순히 이름만 rdb일뿐 메모리 내용을 저장하는 기능 외에는 아무것도 지원하지 않는다. 이렇게 덤프한 내용은 다시 메모리에 올려 사용할 수 있다.(=해당 시점으로 복구할 수 있다.)
- Redis 서버는 1개의 싱글 쓰레드로 수행된다. 따라서 서버 하나에 여러개의 서버를 띄우는 것이 가능하다.
    - Master-Slave 형식으로 구성이 가능하다.
    - 데이터 분실 위험을 없애주는 것이 바로 Master-Slave 방식이다.
    - 위 기능을 이용해 실시간으로 데이터를 다른 서버에 복제한다.
    - Master server가 다운되어도 Slave Server로 접속하면 바로 서비스를 계속할 수 있다.
- Memcached보다 다양한 API를 지원한다.
    - 아래의 경우에는 Redis API가 Memcached API보다 유용하다.
    - 여러개의 캐시를 한번에 업데이트 해야하는 경우 Redis에서는 mset이라는 함수를 사용하면된다. 그런데 Memcached에서는 여러개의 캐시 데이터를 가져오는 건 가능하지만 여러개의 캐시 데이터를 업데이트하는 API는 지원하지 않는다. 많은 양의 캐시를 업데이트 해줘야 하는 상황에서 Memcached를 사용하면 업데이트 해야하는 데이터 양만큼 set API를 호출해야 한다. 반면 Redis는 데이터의 크기를 쪼개서 mset을 호출하면 Memcached로 동작할 때 보다 빠른 시간안에 작업할 수 있다.

## Redis 단점

- 메모리 파편화가 발생하기 쉽다.
    - 메모리를 최대 2배까지 사용한다.
    - Redis는 싱글 쓰레드이다. 그래서 스냅샷을 뜰 때 자식 프로세스를 하나 만들어낸 후 새로 변경된 메모리 페이지를 복사해서 사용한다. Redis는 copy-on-write 방식을 사용한다. 보통 Redis를 사용할 때는 데이터 변경이 잦기 때문에 실제 메모리 크기만큼 자식 프로세스가 복사하게 된다. 그래서 실제로 필요한 메모리 양보다 더 많은 메모리를 사용하게 된다.
- 대규모 데이터에 대한 응답 속도의 불안정성
    - 대규모 트래픽으로 인해 많은 데이터가 업데이트되면 Redis는 Memcached에 비해 속도가 불안정하다.
    - 이것은 Redis와 Memcached의 메모리 할당 구조가 다르기 때문에 발생하는 현상이다.
    - Redis는 jemalloc을 사용하기 때문에 매번 malloc과 free를 통해서 메모리 할당이 이루어진다. 반면 Memcached는 slab 할당자를 이용하여 내부적으로는 메모리 재할당을 하지 않고 관리하는 형태를 취한다. 이로 인해서 Redis는 메모리 파편화가 발생하며 이 할당 비용 때문에 응답 속도가 느려진다. 다만 이는 극단적으로 봤을 때 발생하는 일이다. 대규모 서비스에서도 Redis를 많이 도입하는 것을 보면 일반적으로 스타트업 등에서 사용해도 무방하다 볼 수 있다.

 

## 사용 가능한 데이터형

대표적으로 5가지의 데이터형 사용이 가능하다.

- String, List, Set, Sorted Set, Hash
    - Strings
        - key / value를 사용하는 자료구조.
        - key를 이용해 데이터를 저장하고 가져온다.
        - key와 value를 저장하는 set 명령과 key로 value를 가져오는 get 명령이 있다.
        - 기본적인 Hash Table을 사용한다.
        - Set <key> <value>
        - Get <key>
        - mset <key> <value> <key> <value> …
        - mget <key> <key> <key> …
        - mset과 mget을 사용할 때 최대 50개 정도까지만 쓰는게 좋다. 왜냐하면 레디스는 싱글 쓰레드인데 한번에 계속 돌면 다른 요청을 처리할 수가 없기 때문이다.
    - List
        - 자료구조 리스트를 레디스에서 제공하는 자료구조
        - 중간에 추가/삭제가 느리고 헤드와 테일로만 데이터를 추가,삭제할 때 유용한 데이터구조이다.(O(n)이라 선형 탐색의 비용이 비싼 자료구조이다.)
        - 큐 형태의 자료구조가 필요할 때 많이 사용한다.
        - SideKiq 나 Jesqueue라는 레디스 기반의 큐들이 존재한다.
        - Lpush는 데이터를 왼쪽부터 추가하고, rpush는 오른쪽으로 추가한다.
        - Lpush <key> <value>
        - Rpush <key> <value>
        - Lpop은 데이터를 왼쪽에서 가져오고, rpop은 오른쪽에서 가져온다.
        - lpop <key> , rpop <key>
        - lrange는 리스트의 아이템들을 가져오는 명령이다.
        - lrange <key> <시작 인덱스> <끝 인덱스>
        - 리스트는 잡큐로 가장 많이 사용된다.
        - rpop,lpop은 데이터가 없으면 바로 리턴, brpop은 데이터가 없으면 데이터가 생길때까지 대기한다.
    - Set
        - 유일한 값들만 있는 집합을 유지하는 자료구조.
        - 친구리스트, 팔로워리스트 등을 저장하는데 사용될 수 있다. (특정 그룹을 저장할 때 사용)
        - 스프링 시큐리티 Oauth에서 access token을 저장하는 redis 토큰 store가 Set 자료구조로 처리하고 있다.
        - 빨리 찾아야하고 중복이 없을 때
        - Sadd <key> <item> set에 데이터를 추가한다.
        - Sismemeber <key> <item> set에 해당 item이 있는지 확인한다. 데이터가 있으면 1, 없으면 0
        - Srem <key> <item> set에 해당 item이 있으면 삭제한다.
        - Smembers <key> set의 모든 item을 가져온다.
    - Sorted Set
        - 스코어를 가지는 set 자료구조
        - 아이템들의 랭킹을 가지는데 사용할 수 있다.
        - 스코어는 double 형태이므로, 특정 정수값을 사용할 수 없다는 것에 주의.
        - Skiplist라는 자료구조를 이용한다.
        - Skiplist는 log(n)의 검색속도를 가지는 리스트 자료구조이다.
        - Zadd <key> <score> <item> Sorted set에 아이템을 추가한다. value가 이미 존재하면 해당 score로 변경된다.
        - Zrange <key> <start index> <end index> 요청한 Range의 아이템을 가져온다.
        - Zrevrange <key> <start index> <end index> 요청한 Range의 아이템을 score 역순으로 가져온다.
        - ZRangebyscore <key> <start score> <end score> 요청한 score range의 아이템을 가져온다.
    - Hash
        - redis 자료구조 자체가 해시인데  그 안에 다시 subkey, subvalue를 가지는 구조.
        - 일반적인 key value 데이터를 특정 군의 데이터로 묶고 싶을때 사용
        - hset <key> <subkey> <value> subkey에 value 추가
        - hget <key> <subkey> subkey로 value를 가져오는 명령.
        - hmset <key> <subkey> <value> <subkey> <value> …, hmget <key> <value> <value> <value>…
        - hgetall <key> 모든 subkey와 value를 가져온다. <subkey> <value> <subkey> <value> 형태로 나온다.₩
- 기본적으로 해시 테이블
- List는 head와 tail로만 데이터를 추가, 삭제할 때 유용하다. (큐 형태의 자료구조 필요할 때 많이 사용)
- 컬렉션에 너무 많은 키를 넣으면 안된다.

## 레디스 모니터링

레디스는 모니터링이 필요하다. 왜냐하면 레디스는 많은 트래픽을 처리하기에 문제가 생기면 전체 성능 저하로 이어질 수 있기 때문이다.

### 레디스 Metrics

info all 명령으로 정보를 수집할 수 있는 레디스 자체의 Metrics

![스크린샷 2023-01-01 오후 8.28.20.png](Redis%202080d6d470524efbb3e6cc01a29a42c2/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.28.20.png)

![스크린샷 2023-01-01 오후 8.28.55.png](Redis%202080d6d470524efbb3e6cc01a29a42c2/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.28.55.png)

used_memory_rss : 레디스는 인메모리 솔루션이다 보니까 스왑이 발생하면 해당 페이지 접근때문에 성능이 많이 떨어진다. 그래서 rss를 보고 rss가 실제 물리사용 메모리보다 적도록 유지해야한다. (중요) 

used_memory : 레디스가 할당을 요청한 메모리. used_memory는 2기가 밖에 안되지만 실제로 used_memory_rss는 12기가 정도되는 메모리 파편화 현상이 발생할 수 있다. 그래서 rss 모니터링이 훨씬 중요하다.

![스크린샷 2023-01-01 오후 8.38.56.png](Redis%202080d6d470524efbb3e6cc01a29a42c2/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-01_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.38.56.png)

### 레디스 호스트 Metrics

![Untitled](Redis%202080d6d470524efbb3e6cc01a29a42c2/Untitled.png)

### 사용하는 명령 모니터링

info all을 하면 Commandstats 파트를 확인한다.

**O(N) 관련 명령의 calls와 usec_per_call이 증가하는지를 확인해야 한다.**

![Untitled](Redis%202080d6d470524efbb3e6cc01a29a42c2/Untitled%201.png)

keys같은 명령이 쓰이는지 확인해야한다.  

## 레디스 장애 처리

### 장애의 원인

레디스는 메인 쓰레드가 싱글 쓰레드기 때문에 (레디스 6부터는 멀티 쓰레드 I/O가 들어갔지만) 명령어를 처리하는 거는 한번에 하나만 처리하기 때문에 하나가 오래 걸리면 다른 명령들은 대기해야함.

스케일업을 하더라도 잘못된 사용 패턴은 장애를 일으킬 수 있다.

| 메모리 | 메모리 과다 사용(maxmemory 설정) | maxmemory가 설정되었을 때 maxmemory policy에 따라 더이상 eviction할 수 있는 메모리가 없다면 OOM 에러를 redis가 전달한다. |
| --- | --- | --- |
| 메모리 | rss 관리 | 실제 물리메모리보다 더 많은 메모리를 사용하면 해당 페이지에 swap이 발생하고, swap된 페이지는 해당 프로세스가 종료되기 전까지 접근할 때마다 디스크에 접근할 수 있어 서 성능이 떨어진다. used_memory와 rss를 모니터링 해주고 rss값을 넘지 않도록 데이터를 지워주는 등 관리를 잘 해야한다.  |
| 설정 | 기본 설정 사용 | 기본 설정을 사용 시 Save 설정(현재 메모리를 디스크로 덤프하는 설정)이 1시간에 1개, 5분에 100개, 1분에 10000개가 변경이 되면 동작하게 된다. 실제 프로덕션에서 1분에 10000개 변경은 빈번해서 메모리가 32기가라면 1분마다 32기가를 디스크에 풀덤프 하게된다. (I/O를 과다하게 사용하게 되서 장애가 발생할 수 있다.)  |
| 싱글 스레드 | 과도한 value 크기 | 싱글 쓰레드기 때문에 하나의 명령이 긴 시간을 차지하면 결국 redis 성능저하로 이어진다. value의 크기가 큰데 Hgetall, hvals 등 collection의 데이터를 과도하게 많이 가져오는 명령어를 쓰게되면 속도가 느려지게 된다.⇒전체 성능 저하 |
| 싱글 스레드 | O(N) 명령 사용 | keys나 flushdb/flushall 등 큰 크기의 collection을 지우는 등의 문제는  레디스 성능을 떨어트린다. |

- 메모리 부족으로 인한 이슈
    - 스케일 업, 또는 키를 지워서 메모리 확보( 키를 지우더라도 사실 레디스는 jemalloc을 써서 메모리관리를 하는데 메모리를 들고 있다가 제공해주는 것은 또 별개의 얘기다. 바로 해소하지 않을 수 있다.)
- copy on write 이슈
    - 레디스가 fork 할 때, 메모리 사용량이 최대 2배까지 늘어날 수 있다.
    - replica가 연결이 되는 순간 데이터 이전을 위한 rdb를 만들면서 fork
    - AOF rewrite를 하기 위한 경우 fork (bgrewriteaof 명령)
    - rdb 생성을 하기 위한 fork (bgsave 명령)

- fork를 할 경우 부모와 자식 프로세스가 읽기용 메모리는 공유해서 메모리를 절약한다.
- 공유 메모리에 쓰기가 발생하는 프로세스가 해당 메모리를 복사해서 사용하게 된다.
- 레디스는 child process는 rdb 생성을 담당하기 때문에 읽기만 주로 발생한다.

![스크린샷 2023-01-07 오후 8.05.10.png](Redis%202080d6d470524efbb3e6cc01a29a42c2/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-07_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.05.10.png)

부모 프로세스가 write나 del을 하며 메모리(페이지)에 변경이 일어나면 해당 페이지를 복사하고 write하기에 최대 두배까지 증가할 수 있다.

![스크린샷 2023-01-07 오후 8.10.35.png](Redis%202080d6d470524efbb3e6cc01a29a42c2/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-07_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.10.35.png)

### 메모리 관련 장애 확인 방법

**어플리케이션 레벨에서 확인**

- API별 latency 측정 ⇒ 전체적으로 느려진다.
- 레디스 관련 호출에서 시간이 얼마나 걸리는지 확인
- 레디스 응답이 무엇이 오는지 확인한다. ⇒ 에러가 오면 이슈가 있다.

**레디스 레벨에서 확인**

- 메모리 사용량이 얼마인지 확인한다.
    - used memory와 rss가 현재 설정된 메모리 크기와 유사할 경우 문제가 있는 것.
    - OS와 다른 프로세스에서 사용하는 메모리 사이즈가 있으므로 80%미만으로 쓰는게 좋다.
- slow log가 남는지 확인한다.

### 메모리 관련 장애 해결 방법

- 메모리가 더 큰 장비로 업그레이드 한다. (레디스는 항상 fork의 위험이 있으므로 메모리가 충분할 수록 좋다.)
- 효율성이 떨어지는 key를 지운다. (레디스는 개별 key의 hit,miss를 보여주지 않으므로 따로 관리해야 한다.) ⇒ 어플리케이션에서 키가 hit,miss 되는지 로그 남기기 ⇒ 실제 캐시되는 키가 줄어드므로 db 부하가 늘어날 수 있다.

### 레디스 기본 설정 관련 장애

- 레디스 기본 설정 사용으로 인해 과도한 IO로 인한 성능 저하
- bgsave 동작이 fork로 인해 메모리 사용량이 늘어날 수 도 있다.

### 레디스 기본 설정 관련 장애 확인 방법

**서버 레벨에서 확인**

- 디스크 사용량이나 네트워크 사용량을 확인한다.

**레디스 레벨에서 확인**

- save 관련 설정을 확인한다. config get save
    
    ![스크린샷 2023-01-07 오후 8.27.17.png](Redis%202080d6d470524efbb3e6cc01a29a42c2/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-07_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_8.27.17.png)
    

### 기본 설정 관련 장애 해결 방법

- save 설정을 끄고 사용한다. ⇒ rdb 생성을 아예 안함. ⇒ 백업은 새벽이나 부하가 적은 시간에 맞춰 스케줄링을 해서 따로 돌리기

### 레디스 싱글 쓰레드 관련 장애

- 과도한 value로 인해 발생하는 장애

### 레디스 싱글 쓰레드 관련 장애 확인 방법

- 사용하면 안되는 명령을 사용 중인지 확인한다.
    - keys 명령의 사용 횟수가 계속 늘어나면 해당 명령이 문제를 일으킬 수 있다. ⇒ keys 명령 대신에 scan 사용 (keys와 scan 차이)
- O(N) 계열 커맨드의 사용이 늘어나는지 확인한다.
    - Hgetall, hvals, smembers, zrange 계열 함수
- Monitor 명령을 통해 들어오는 key들의 빈도를 체크한다. (어떤 명령이 들어오고 데이터 얼마나 나가는지)
    - 모니터 명령은 해당 서버에 부하를 주므로 부하가 큰 시간은 피해서
- Scan 명령으로 각 key의 사이즈를 확인해서 특정 크기 이상의 key를 확인한다. (키가 몇 mb이상이다 하면 처리 필요)

위에서 말한 info all을 통해 Commandstats 파트를 확인한다.

# 영속성(persistence)

인메모리 구조로만 서비스가 구성되어 있다면, 장애 상황에서 데이터의 손실이 발생할 수 있다. Redis는 디스크에 다양한 방법으로 데이터를 저장하며 데이터의 영속성을 보장한다.

- RDB(Redis Database) : point-in-time으로 데이터 스냅샷을 생성하여 디스크에 저장
- AOF(Append Only File) : Operation Log(Write, Update)에 대한 로그를 기반으로 데이터를 재적재 하는 방법
- No persistence : 영속성 보장을 안하는 방법
- RDB + AOF : RDB와 AOF 방식을 모두 사용, 주기적으로 RDB 방식으로 스냅샷 저장, 그 외에는 AOF 방식으로 데이터 보존

### AOF

![스크린샷 2023-01-12 오후 11.18.21.png](Redis%202080d6d470524efbb3e6cc01a29a42c2/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-12_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.18.21.png)

전달된 명령을 별도의 파일에 기록하는 방법. RDBMS의 Redo 메커니즘과 유사하다. AOF의 역할은 재기동시 파일에 기록된 명령어를 일괄 수행하여 데이터를 복구하는데 사용된다. AOF의 장점으로는 데이터 유실이 발생하지 않는다. 하지만 매 명령어마다 File과의 동기화가 필요하기 때문에 처리속도가 현격히 줄어든다. 따라서 이를 해소하기위해 File Sync 옵션(appendfsync)이 존재하며, 해당 옵션에 따라 Sync 주기를 조절할 수 있으나 그만큼 데이터 유실이 발생할 수 있다.

### **RDB**

반면 RDB는 특정 시점의 메모리 내용을 복사하여 파일에 기록하는 방법으로 RDBMS Full Backup에 해당한다. 따라서, 정기적 혹은 비정기적으로 저장이 필요할 시점에 데이터를 저장이 가능하다. RDB의 장점으로는 AOF에 비해 부하가 적으며, LZF 압축을 통해 파일 압축이 가능하다. 또한 덤프파일을 그대로 메모리에 복원(Restore)하므로 AOF에 비해 빠르다. 반면 덤프를 기록한 시점이후 데이터는 저장되지 않으므로 복구시에 데이터 유실이 발생할 수 있는 문제점이 있다.

![스크린샷 2023-01-13 오전 12.26.58.png](Redis%202080d6d470524efbb3e6cc01a29a42c2/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_12.26.58.png)

AOF와 RDB를 사용할 때는 유의해야할 점이 있다. 바로 Copy On Write다. AOF를 백그라운드로 수행하거나 RDB를 수행할때 redis-server에서 자식 프로세스를 fork하여 처리를 위임한다. 만약 이과정에서 redis-server의 데이터에 쓰기 작업을 수행한다면, 기존 페이지를 수정하는 것이 아닌 이를 별도 공간에 저장 후 처리한다. 따라서 해당 작업을 수행도중에 쓰기 작업이 증가한다면, 메모리 사용량이 급격히 증가될 수 있다.(최대 2배)

# Redis Replication(복제)

Redis는 충분히 빠르고 안정적이다. 하지만 트래픽이 몰린다면 어떻게 될까?
서버의 한계점을 넘어간다면, 인스턴스 장애가 발생할 수 있다. 이때 만약 단일 인스턴스로만 구성되었다면, Redis의 장애가 모든 Application에 영향을 미친다.
한편, Redis를 운영하는 입장에서 버전 업그레이드 혹은 서버 PM 작업이 필요하나 Application 영향도로 인해 섯불리 작업할 수 없는 문제가 생긴다.
마지막으로, 캐시 목적으로 사용하는 Redis는 쓰기 작업보다는 읽기 작업이 주로 발생한다. 따라서 읽기 작업 성능을 높힐 수 있는 아키텍처 구성이 필요할 수 있다.
이를 위해 Redis에서는 어느정도 고가용성을 확보 및 쓰기/읽기 작업 성능을 개선할 수 있는 Master/Replica 토폴로지를 제공한다.

![스크린샷 2023-01-13 오전 12.30.59.png](Redis%202080d6d470524efbb3e6cc01a29a42c2/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-01-13_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_12.30.59.png)

위 그림은 Master/Replica의 구조를 나타낸다.
최초 Master/Replica 구성시 Master의 데이터는 모든 Replica에 복사한다. 따라서 어느 Redis 인스턴스에서 데이터를 조회해도 원하는 결과를 얻을 수 있다.
만약 데이터의 변경이 발생한다면, 변경 작업은 Master에서만 가능하다. 이후 변경된 데이터는 비동기적으로 모든 Replica에게 전달되어 반영된다.
(※ replica-read-only 옵션을 no로 설정하면, Replica 상태를 변경할 수 있으나 전체 동기화가 발생하면 모두 유실되므로 추천하지 않는다.)
이러한 과정은 Oracle Data Guard의 SQL Apply 서비스와 유사하다. 데이터가 아닌 문장(Statement)이 전달되므로 LuaScript가 적용된 문장이라면 Master와 Replica의 결과가 다를 수 있다.

### **Master/Replica** 동기화 과정

# Redis HA(고가용성)

## Redis 트랜잭션 - Multi, Exec

레디스는 싱글 쓰레드 형태기 때문에 명령들이 atomic을 보장해준다. 이 atomic을 보장해줄때도 여러 명령이 동시에 수행되길 원할 때 사용할 수 있는 방법

- 레디스에서 한번에 실행되는 것을 보장해주는 명령
- **Multi**

Exec가 나올때까지 명령을 모아서 대기한다.

- **Exec**

Exec를 실행하면 Multi로 모인 명령이 순서대로 실행된다.

Exec를 실행하면 Multi로 모인 명령이 다른 명령의 수행없이 수행된다.

Redis는 싱글 쓰레드 형태이기 때문에 다른 명령이 이 동안에 수행되지 않는다. 또한, 너무 많은 작업이 있으면 전체 Redis성능이 떨어진다.

## Redis 파이프라인

레디스를 사용하다보면 레디스 성능이 빠르지 않다고 느낄때가 종종 있다. 

왜냐하면 명령을 수행하고 응답을 기다리는 동안 Time gap이 존재하기 때문이다.

동기적으로 명령을 보내는 경우 응답을 기다리지 않고 명령을 미리 보내는 방식.

**redis pipeline vs non-pipiline**

100만 개를 set 하는 테스트에서 10배 이상의 차이가 난다.

- 실제로 redis에서 제공하는 기능이 아니라, 라이브러리에서 제공하는 방식이다.

## CRUD에 따른 Redis 데이터 처리

- Redis 서버는 클라이언트에서 Read 요청이 들어올 때 메인 서버로부터 값을 가져와 저장한다. 이 때 메인 서버와 싱크된 데이터 이외에 추가로 데이터 만료 시점을 처리하기 위해 현재 시간이나 만료시간을 함께 저장 해야한다.

### Read 요청시

- Redis 서버에서 사용자가 요청한 데이터가 있는지 확인한다. 데이터가 존재하는 경우 만료 여부 확인 후 이 정보를 반환한다. 정보를 반환한 시간을 현재로 업데이트 후 종료한다. 데이터가 만료되었거나 없는 경우는 삭제 후 메인 서버에 요청한다. 메인 서버로 부터 받은 데이터를 캐싱 및 DB에 저장 후 이 값을 방문자에게 반환 후 종료한다.

### CUD 요청시

- 이 경우 조회과정과는 조금 다르다. 그 이유는 데이터에 변화가 생겼으므로 해당하는 값의 데이터는 캐싱 값이 아닌 현재 실시간 정보를 보내줘야한다.
- 방문자의 CUD를 메인 서버에 요청한다. 메인 서버는 요청받은 CUD 작업을 반영 및 업데이트한다. 변경되기 전 데이터 값을 Redis에서 찾아 삭제 후 종료한다.
- 여기서 중요한 점은 캐싱을 제공하는 경우 단순하게 정보를 제공하는 부분만 고려하는 것이 아니라 다양한 상황에 대처해야 한다는 점이다. 예를 들어 CUD처럼 데이터에 중요한 변경 사항이 있는 경우 기존의 캐싱 데이터를 삭제하는 과정을 들 수 있다.

출처 : [https://goodgid.github.io/Redis/](https://goodgid.github.io/Redis/)

[https://box0830.tistory.com/400](https://box0830.tistory.com/400)
