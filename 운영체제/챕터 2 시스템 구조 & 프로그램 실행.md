# 챕터 2 시스템 구조 & 프로그램 실행

# 챕터 2

메모리는 CPU의 작업공간

![Untitled](/image/os/chapter2/Untitled.png)

레지스터 = Cpu안에 존재. 메모리보다 빠르면서 정보를 저장할 수 있는 작은 공간 

모드 빗 = CPU에서 실행되는 것이 운영체제인지 사용자 프로그램인지 구분해주는 것

입출력이 들어오면 사용자 프로그램이 CPU를 운영체제에 넘겨주고 운영체제가 디바이스 컨트롤러와 통신, 입력 기다리는 동안 CPU한테 또 다른일 시키다가 입력이 다 들어오면 인터럽트 발생  

CPU는 메모리에 올라온 프로그램의 인스트럭션을 수행하고 인터럽트 확인 (반복)

인터럽트 발생하면 하던일을 멈추고 CPU 제어권이 사용자 프로그램에서 운영체제로 넘어감

### 모드 빗

모드 빗 0이면 CPU가 운영체제에 할당되어있는 상태, 메모리 접근이나 IO디바이스 접근 가능

모드 빗 1이면 사용자 프로그램이 CPU 가지고 있기 때문에 제한된 인스트럭션만 사용가능

### 타이머

- 시분할을 위해 사용
- CPU를 특정 프로그램이 독점하는 것 방지
- 정해진 시간이 흐른뒤 운영체제에게 CPU 제어권이 넘어가도록 인터럽트 발생시킨다.(타이머 값 0이 되면)

### I/O 디바이스 컨트롤러

- 해당 I/O 장치유형을 관리하는 일종의 작은 CPU
- local buffer를 가짐(일종의 데이터 레지스터)
- 디바이스 컨트롤러는 I/O가 끝났을 경우 인터럽트로 CPU에 그 사실을 알림

### DMA 컨트롤러

- 너무 많은 인터럽트때문에 CPU 효율이 떨어짐
- 중간에서 관리자 역할. 입출력 들어오면 자기가 local 버퍼에 있는 데이터를 사용자 프로그램에 넣고 CPU한테 한번에 보고함
- 원래는 CPU만 메모리에 접근 가능하지만 DMA도 메모리에 접근 가능하다.
- CPU의 많은 인터럽트를 줄이기 위한 목적

### 입출력의 수행

- 사용자 프로그램은 운영체제를 통해서만 I/O장치에 접근가능

### 시스템 콜

- 사용자 프로그램이 운영체제에게 I/O 요청하는 것
- I/O 뿐만 아니라 사용자 프로그램이 운영체제 호출할때 발생

### 인터럽트

- 인터럽트(하드웨어 인터럽트): 하드웨어가 발생시킨 인터럽트
- 트랩(소프트웨어 인터럽트)
    - exception: 프로그램이 오류를 범한 경우
    - 시스템 콜: 프로그램이 커널함수를 호출(운영체제 호출)하는 경우

### 인터럽트 관련 용어

- 인터럽트 벡터: 해당 인터럽트의 처리 루틴 주소를 가지고 있음
- 인터럽트 처리 루틴: 인터럽트 종류마다 무슨 일을 해야할지 정의된 함수(해당 인터럽트를 처리하는 커널함수)

### 동기식 입출력, 비동기식 입출력

- 동기식 입출력: I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
- 비동기식 입출력: I/O가 시작된 후  입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

![Untitled](/image/os/chapter2/Untitled-1.png)

- 두 경우 모두 I/O의 완료는 인터럽트로 알려줌

### 저장장치 계층 구조

![Untitled](/image/os/chapter2/Untitled 2.png)

### 프로그램의 실행(메모리 로드)

![Untitled](/image/os/chapter2/Untitled 3.png)

- 프로그램은 실행파일 형태로 하드디스크에 저장되어있음 ⇒ 실행하면 메모리에 올라가서 프로세스가 된다.
- 프로그램을 실행하면 독자적인 메모리 주소공간이 만들어지는데 이게 다 물리메모리에 들어가면 메모리 낭비가 되므로 실행중인 부분만 물리메모리에 올라가고 나머지는 스왑 area에 들어간다.
- 논리적 주소는 주소변환을 통해 물리메모리에 올라간다.

### 커널 주소 공간의 내용

![Untitled](/image/os/chapter2/Untitled 4.png)

### 프로그램의 실행

![Untitled](/image/os/chapter2/Untitled 5.png)
