# 자료구조

### 자료구조는 데이터들의 모임, 관계, 함수, 명령 등의 집합을 의미한다.

- 처리하고자 하는 데이터들이 모여있는 형태
- 처리하고자 하는 데이터들 사이의 관계(수직, 상하, 일방적, 상호 관계등)을 정의한 것
- 데이터들을 사용하기 용이하게 저장해 놓은 형태
- 자료 구조를 잘 선택하면 사용하는 메모리를 최소화 할 수 있으며 시간, 공간적으로 효율성을 확보할 수 있다.

# ArrayList vs LinkedList

### ArrayList

- 논리적 저장순서와 물리적 저장순서가 일치한다.
- 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)로 해당 원소에 접근할 수 있다.
- 하지만 삽입, 삭제의 경우 O(n)의 시간복잡도를 가지는데 삭제의 경우 빈공간이 생겨 뒤의 원소들을 shift하는 비용이 발생하기 때문이다. 삽입 역시 뒤의 원소들을 shift하기 때문에 O(n)의 시간복잡도를 가진다.

### LinkedList

- 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 O(1)로 해결할 수 있다.
- 하지만 원하는 위치에 삽입을 하고자 하면 원하는 위치를 탐색하는 과정에서 첫번째 원소부터 다 확인을 해야한다. ArrayList와 달리 논리적 저장순서와 물리적 저장순서가 일치하지 않기 때문이다. 이 과정 때문에 원소를 찾느데 O(n)의 시간 복잡도를 갖고 결국 삽입 삭제도 O(n)의 시간복잡도를 가진다.

### 개인적 추천

- Array를 기반으로 LinkedList 구현
- ArrayList를 기반으로 LinkedList 구현

# Stack, Queue

### Stack

- 선형 자료구조의 일종으로 LIFO 즉, 나중에 들어간 원소가 먼저 나오는 특징이 있다. 먼저 스택에 들어간 원소는 맨 바닥에 깔리게 된다.
- 스택 사용 사례
    - 재귀 알고리즘
    - 웹 브라우저 방문 기록(뒤로가기)
    - 실행취소(undo)
    - 역순 문자열 만들기
    - 수식의 괄호 검사

[https://gmlwjd9405.github.io/2018/08/03/data-structure-stack.html](https://gmlwjd9405.github.io/2018/08/03/data-structure-stack.html)

### Queue

- 선형 자료구조의 일종으로 FIFO 즉, 먼저 들어간 원소가 먼저 나온다. 자바 컬렉션에서 큐는 인터페이스이다. 이를 구현하고 있는 Priority Queue 등을 사용할 수 있다.
- 큐의 사용 사례
    - 너비 우선 탐색 구현
    - 캐시 구현
    - 우선순위가 같은 작업 예약(인쇄 대기열)
    - 선입 선출이 필요한 대기열(티켓 카운터)
    - 윈도우 시스템의 메시지 처리기
    - 프로세스 관리

[https://gmlwjd9405.github.io/2018/08/02/data-structure-queue.html](https://gmlwjd9405.github.io/2018/08/02/data-structure-queue.html)

### 개인적 추천

- 스택을 사용하여 미로찾기 구현
- 큐를 사용하여 힙 구현
- 스택 두개로 큐 구현
- 스택으로 괄효 유효성 체크

# Tree

- 비선형 자료구조이다. 트리는 계층적 관계를 표현하는 자료구조이다.
- 트리는 표현에 집중한다. 무언가를 저장하고 꺼내야 한다는 사고에서 벗어나 트리라는 자료구조를 바라보자
- 트리는 이진트리, 이진 탐색 트리, 균형트리(AVL 트리, 레드블랙트리), 이진 힙(최소힙,최대힙) 등이 있다.

### 트리 용어

- 노드 : 트리를 구성하는 각각의 요소를 의미한다.
- 간선  : 트리를 구성하기 위해 노드와 노드를 연결하는 선
- 루트 노드: 트리 구조에서 최상위에 있는 노드
- 단말 노드(리프 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드

### 이진 트리(Binary Tree)

- 루트 노드를 중심으로 두개의 서브 트리(큰 트리에 속하는 작은 트리)로 나뉘어진다. 나뉘어진 두 서브 트리도 모두 이진 트리여야 한다.
- 트리에서는 각 층별로 레벨을 매기는데 레벨의 값은 0부터 시작하고(루트 노드의 레벨이 0) 트리의 최고 레벨을 가리켜 해당 트리의 높이라고 한다.
- 모든 레벨이 꽉찬 이진 트리를 포화 이진트리라고 한다.
- 순서대로 채워진 이진트리를 완전 이진 트리라고 한다.
- 이진트리를 배열로 구성하면(노드의 개수가 n개이고 루트가 1에서 시작할 때) i번째 노드에 대해서 부모는 i/2, 왼쪽 자식은 2*i, 오른쪽 자식은 2*i+1의 인덱스를 가진다.

### BST(Binary Search Tree)

- 이진 탐색트리는 이진 트리의 일종이다.
- 단 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.
    - 규칙 1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.
    - 규칙 2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
    - 규칙 3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
    - 규칙 4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.
- 이진 탐색 트리의 탐색 연산은 **O(log n)**의 시간복잡도를 갖는다. 정확히 말하면 O(h)라고 표현할 수 있는데(h는 트리의 높이) 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두배씩 증가하기 때문이다.
- 이진탐색 트리는 편향트리가 될 수 있다. 저장 순서에 따라 계속 한쪽으로만 노드가 추가되는 경우가 발생하기 때문이다. 이런 경우 성능에 영향을 미치게 되며 시간복잡도는 **O(n)**이 된다.
- 배열보다 많은 메모리를 사용하며 데이터를 저장했지만 시간복잡도가 같게되는 비효율적인 상황이 발생한다. 이를 해결하기 위해 Rebalancing 기법이 등장했다. 균형을 잡기 위한 트리 구조의 재조정을 Rebalancing이라한다. 이 기법을 구현한 트리에는 여러 종류가 있는데 Red-black 트리가 그중 하나이다.

### 개인적 추천

- BST 구현하기
- 주어진 트리가 이진트리인지 확인하는 알고리즘 구현하기

# Heap

- 트리 형식을 하고있으며 트리 중에서도 배열에 기반한 완전 이진트리이다. 배열에 트리의 값들을 넣어줄때 0번째는 건너뛰고 1번 인덱스부터 루트노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함이다.
- 힙에는 최소힙과 최대힙 두 종류가 있다.
- 최대 힙이란 각 노드의 값이 해당 자식의 값보다 크거나 같은 완전 이진트리를 말한다.(최소힙은 반대)
- 최대 힙에서 루트 노드에 있는 값이 제일 크므로 최대값을 찾는데 소요되는 연산의 시간복잡도는 O(1)이다. 하지만 힙의 구조를 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요한데 맨 마지막 노드를 루트 노드로 대체 시킨 후 힙 구조를 유지하는 과정에는 **O(log n)**의 시간복잡도를 가진다.(삽입, 삭제)

### 개인적 추천

- 힙 구현하기

# 레드 블랙 트리

- BST를 기반으로 하는 트리형식의 자료구조이다. 레드 블랙 트리는 데이터를 저장하게 되면 탐색 ,삽입, 삭제에 O(log n)의 시간복잡도가 소요된다. 동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어이다. depth가 최소가 되는 경우는 트리가 완전 이진 트리인 경우이다.

### 레드 블랙 트리의 정의

레드 블랙 트리는 다음의 성질들을 만족하는 BST이다.

- 각 노드는 레드 또는 블랙이라는 색을 갖는다.
- 루트 노드의 색은 블랙이다.
- 각 리프노드는 블랙이다.
- 어떤 노드의 색이 레드라면 두개의 자식은 모두 블랙이다.
- 모든 노드에 대해서 그 노드로부터 자손인 리프노드에 이르는 모든 경로에는 동일한 개수의 블랙 노드가 존재한다. 이를 해당 노드의 black-height라고 한다.
- black-height: 노드 x로부터  노드 x를 포함하지 않은 단말 노드 까지의 단순 경로 상에 있는 블랙 노드들의 개수

## 레드 블랙 트리의 특징

- 이진 탐색 트리이므로 BST의 특징을 모두 갖는다.
- 루트 노드로부터 단말 노드까지의 모든 경로중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. 이러한 상태를 balanced 상태라고 한다.
- 노드의 자식이 없을 경우 자식을 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL들을 단말 노드로 간주한다.

### 레드 블랙 트리는 BST의 삽입,삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어진 자료구조이다. 어떻게 해결하는가?

### 삽입

- 우선 BST의 특성을 유지하면서 노드를 삽입한다. 그리고 삽입된 노드의 색을 RED로 지정한다. 레드로 지정하는 이유는 black-height 변경을 최소화하기 위함이다. 삽입 결과 레드블랙트리의 특성 위배 시 노드의 색을 조정하고 black-height가 위배되었다면 rotation을 통해 height를 조정한다. 이러한 과정을 통해 레드블랙트리의 동일한 height에 존재하는 단말노드가 아닌 노드들의 black-height가 같아지게 되고 최소 경로와 최대 경로의 크기 비율이 2 미만으로 유지된다.

### 삭제

- 삭제도 삽입과 마찬가지로 BST의 특성을 유지하면서 해당 노드를 삭제한다. 삭제될 노드의 자식의 개수에 따라 rotation 방법이 달라지게 된다. 만약 지워진 노드의 색깔이 블랙이라면 black-height가 1 감소한 경로에 블랙 노드가 1개 추가되도록 로테이션하고 노드의 색깔을 조정한다. 지워진 노드의 색이 레드라면 위배가 발생하지 않으므로 레드블랙 트리가 그대로 유지된다.

### 자바 컬렉션에서 TreeMap도 내부적으로 레드 블랙 트리로 이루어져 있고 HashMap에서의 Separate Chaining에서도 사용된다. 그만큼 효율이 좋고 중요한 자료구조이다.

[https://code-lab1.tistory.com/62](https://code-lab1.tistory.com/62)

# 트라이(Trie, Prefix Tree)

- 문자열에서 검색을 빠르게 도와주는 자료구조
- 정수형에서 이진탐색트리를 이용하면 시간복잡도가 O(log n)이지만 문자열에서는 문자열 최대길이를 M이라 했을때 O(M*log n)이된다.
- 트라이를 활용하면 O(M)으로 문자열 검색이 가능하다.
- 텍스트 자동완성 기능과 같이 문자열을 저장하고 탐색하는데 유용한 자료구조이다.

### 트라이 자료구조 형태

- 각 노드는 키-값 맵을 가지고 있다. 여기서 키는 하나의 알파벳이 되고 값은 그 키에 해당하는 자식노드가 된다.

![Untitled](/image/dataStructure/Untitled.png)

다음 그림은 DEV, DEAR, PIE, POP, POW라는 단어가 들어있는 트라이 자료구조를 도식화한 것 

휴대폰 전화번호부에서 검색을 하거나 사전에서 단어를 찾는 것과 같다.

예를들어, 다음 그림에서 ‘DEV’라는 문자열을 찾으려면 루트 노드에서부터 순차적으로 D→E→V로 탐색한다.

- 루트 노드는 특정 문자를 의미하지 않고 자식 노드만 가지고 있다.
- 유의할 점은 노드들이 ‘부모노드’나 ‘자신이 어떤 알파벳(키)에 해당하는 노드(값)인지’를 가지고 있는게 아니라는 것이다.
- 즉 루트노드는 D,P라는 알파벳을 키로 하는 자식 자식노드들을 가지고 있고 D는 E를 키로 하는 자식노드, P는 I와O를 키로 하는 자식노드들을 가지고 있는 것이다.
- 루트 노드를 제외한 노드의 자손들은 해당 노드와 공통 접두어를 가진다는 특징이 있다.

![Untitled](/image/dataStructure/Untitled1.png)

### 트라이 자료구조의 특징

- 정렬된 트리 구조이다.(데이터에 따라 이진트리일 때도 있다.)
- 트라이는 자식노드를 맵<키,값>형태로 가지고 있다.
- 루트를 제외한 노드의 자손들은 해당 노드와 공통 접두어를 가진다.
- 루트 노드는 특정 문자가 할당되어있지 않다.

# B Tree, B+ Tree

### B트리

B Tree란 하나의 노드에 여러 자료가 배치되는 트리 구조이다. 한 노드에 M개의 자료가 배치되면 M차 B-Tree라고 한다. 5차 B-Tree인 경우 자식 노드가 최대 5개인 것을 의미한다. B-Tree는 스스로 균형을 맞추는 트리이다. 그래서 최악의 경우에도 O(log N)의 검색 성능을 보인다. 또한 B-Tree는 하나의 노드에 많은 수의 데이터를 저장할 수 있다.

데이터 베이스, 파일 시스템에서 널리 사용되는 트리 자료구조의 일종이다. 이진 트리를 확장해서 더 많은 수의 자식을 가질 수 있게 일반화 시킨 것이 B-트리이다.

Ex) 대량의 데이터를 처리해야 할때, 검색 구조의 경우 하나의 노드에 많은 데이터를 가질 수 있다는 것은 큰 장점이다. 대량의 데이터는 메모리보다 하드디스크나 SSD에 저장되어야 하는데 이들 외부 기억 장치들은 블럭 단위로 입출력을 하기 때문이다. 예를 들어 한 블럭이 1024바이트라면 2바이트를 읽으나 1024바이트를 읽으나 입출력에 대한 비용은 동일하다. 따라서 하나의 노드를 1024버ㅏ이트가 되도록 조절한다면 입출력 면에서 매우 효율적인 구성이 된다. 이런 장점으로 실제 B-Tree는 데이터베이스 시스템의 인덱스 저장 방법으로 애용되고 있다.

### 규칙

- 노드의 자료수가 N이라면 자식의 수는 N+1이어야 한다.
- 각 노드의 자료는 정렬된 상태여야 한다.
- 노드의 자료Dk의 왼쪽 서브트리는 Dk보다 작은 값들이고 오른쪽 서브트리는 Dk보다 큰 값들이어야한다.
- Root노드는 적어도 2개이상의 자식을 가져야 한다.
- 루트 노드를 제외한 모든 노드는 적어도 M/2개의 자료를 가지고 있어야한다.
- 입력 자료는 중복 될 수 없다.

![Untitled](/image/dataStructure/Untitled2.png)

위의 그림은 차수가 3인 B트리이다 .파란색 부분은 각 노드의 키를 나타내며 빨간색 부분은 자식 노드들을 가리키는 포인터다. 키들은 노드 안에서 항상 정렬된 값을 가지며 이진탐색트리처럼 각 키들의 왼쪽 자식들은 항상 키보다 작은 값을 오른쪽은 큰 값을 가진다.

[https://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Tree](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree)

### B+ 트리

- 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드가 추가로 있다.
- 기존의 B-트리와 데이터의 연결리스트로 구현된 색인 구조
- B-트리의 변형 구조로 인덱스 부분과 단말 노드로 구성된 순차 데이터 부분으로 이루어진다. 인덱스 부분의 키 값은 단말 노드에 있는 키 값을 직접 찾아가는데 사용한다.

**장점**

- 블럭 사이즈를 더 많이 이용할 수 있다.(키 값에 대한 하드디스크 액세스 주소가 없기 때문)
- 단말 노드끼리 연결 리스트로 연결되어 있어서 범위 탐색에 매우 유리하다.

**단점**

- B-트리의 경우 최상 케이스에서는 루트에서 끝날 수 있지만 B+ 트리는 무조건 단말 노드까지 내려가봐야 한다.

### B-Tree와 B+ Tree 비교

**B-트리** 

- 각 노드에 데이터가 저장된다.
- 각 노드에서 키와 데이터 모두 들어갈 수 있고 데이터는 디스크 블록으로 포인터가 될 수 있다.

**B+ Tree**

- 인덱스 노드와 단말 노드로 분리되어 저장된다.
- 각 노드에서 키만 들어간다. 따라서 데이터는 단말노드에만 존재한다.
- 삽입, 삭제 연산 모두 단말 노드에서만 이루어진다.
- 또한 단말 노드는 서로 연결되어 있어서 임의 접근이나 순차 접근 모두 성능이 우수하다.

[https://velog.io/@emplam27/자료구조-그림으로-알아보는-B-Plus-Tree](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree)

# 그래프

cf) 트리 또한 그래프이며 그 중 사이클이 허용되지 않는 그래프를 말한다.

### 그래프 관련 용어 정리

- 방향 그래프, 무향 그래프 : 정점과 간선의 연결관계에 있어서 방향성이 있는 그래프, 없는 그래프
- degree: 무향 그래프에서 각 정점에 연결된 간선의 개수를 degree라 한다. 방향 그래프에서는 간선에 방향성이 존재하기 때문에 degree가 두개로 나뉘게 된다. 각 정점으로부터 나가는 간선의 개수를 outdegree,  들어오는 간선의 개수를 indegree라고 한다.
- 가중치 그래프: 간선에 가중치 정보를 두어서 구성한 그래프
- 부분 그래프 : 본래의 그래프의 일부 정점 및 간선으로 이루어진 그래프

### 그래프를 구현하는 두 방법

- 인접 행렬: 정방 행렬을 사용하는 방법
    - 해당하는 위치의 value값을 통해서 정점 간의 연결 관계를 O(1)로 파악할 수 있다. 간선의 개수와 무관하게 V^2의 공간 복잡도를 갖는다. 간선의 수가 많을 때 적절하다.
- 인접 리스트: 연결리스트르 사용하는 방법
    - 정점의 연결 정보를 확인해야하므로 정점간 연결되어 있는지 확인하는데 오래걸린다. 공간 복잡도는 O(E+V)이다.간선의 정보가 적을 때 적합하다.

### 그래프 탐색

**BFS, DFS**

### 최소 스패닝 트리(MST)

그래프의 모든 정점이 사이클 없이 연결된 최소 간선 비용 트리

![Untitled](/image/dataStructure/Untitled3.png)

[https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html](https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html)

# HashMap과 Hash Table

**해시 맵과 해시 테이블을 정의한다면 ‘키에 대한 해시 값을 사용하여 값을 저장하고 조회하며, 키-값 쌍의 개수에 따라 동적으로 크기가 증가하는 associtate array라고 할 수 있다.**

해시 테이블 또한 맵의 인터페이스를 구현하고 있기 때문에 해시맵과 해시테이블이 제공하는 기능은 같다. 다만 해시맵은 보조 해시 함수를 사용하기 때문에 보조 해시 함수를 사용하지 않는 해시 테이블에 비하여 해시 충돌이 덜 발생하므로 성능상 이점이 있다.

- hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다. 특정한 값을 탐색하는데 데이터 교유의 인덱스로 접근하게 되므로 평균적으로 O(1)의 시간복잡도를 갖는다. 하지만 문제는 이 인덱스로 저장되는 key값이 불규칙 하다는 것이다.
- 그래서 특별한 알고리즘을 이용하여 저장할 데이터와 연관된 고유한 숫자를 만들어 낸뒤 이를 인덱스로 사용한다. 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에 삽입 연산 시 다른 데이터의 사이에 끼어들거나 삭제시 다른 데이터로 채울 필요가 없으므로 연산에서 추가적인 비용이 없도록 만들어진 구조이다.

### Hash Function

특별한 알고리즘 이란 것을 통해 고유한 인덱스 값을 설정하는 것이 중요해보인다. 특별한 알고리즘을 **hash method 또는 해시 함수**라고 하고 이 메소드에 의해 반환된 데이터의 고유 숫자 값을 **해시코드**라고 한다. 저장되는 값들의 키 값을 해시 펑션을 통해 작은 범위의 값들로 바꿔준다.

하지만 어설픈 해시 펑션을 통해서 키값들을 결정한다면 동일한 값이 도출될 수가 있다. 이렇게 되면 동일한 키값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 것인데 이를 Collision이라고한다. 

**Collision: 서로 다른 두개의 키가 같은 인덱스로 해싱되면 같은 곳에 저장할 수 없게 된다.**

### 그렇다면 좋은 해시 펑션은 어떤 조건들을 갖추고 있어야하는가?

일반적으로 좋은 해시 펑션은 키의 일부분을 참조하여 해시 값을 만들지 않고 키 전체를 참조하여 해시값을 만들어 낸다. 하지만 좋은 해시함수는 키가 어떤 특성을 가지고 있느냐에 따라 달라지게 된다.

해시 펑션을 무조건 1:1로 만드는 것보다 Collision을 최소화하는 방향으로 설계하고 발생하는 Collision에 대비해 어떻게 대응할 것인가가 더 중요하다. Collision이 많아질수록 탐색에 필요한 시간복잡도가 O(1)에서 O(n)에 가까워진다. 어설픈 해시 펑션은 해시를 해시답게 사용하지 못하도록한다. 좋은 해시펑션을 선택하는 것은 해시 테이블의 성능 향상에 필수적이다.

따라서 해싱된 인덱스에 이미 다른 값이 들어있다면 새 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있다는 것이다. 따라서 충돌 해결은 필수이며 그 방법들에 대해 알아보자

### Resolve Confilct( 충돌 해결)

- **Open Address방식(개방 주소법)**
    - 해시 충돌이 발생하면 다른 해시 버켓에 해당 자료를 삽입하는 방식
    - 공개 주소 방식이라고도 불리는 이 알고리즘은 충돌이 발생하면 데이터를 저장할 장소를 찾아 헤맨다. 최악의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. 이 과정에서도 여러 방법들이 존재하는데 다음 세가지에 대해 알아보자
    1. 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다.
    2. 2차 함수를 이용해 탐색할 위치를 찾는다.
    3. 하나의 해쉬함수에서 충돌이 발생하면 2차 해시함수를 이용해 새로운 주소를 할당한다. 위 두가지 방법에 비해 많은 연산량을 요구한다.
- **Separate Chaining 방식(분리 연결법)**
    - 일반적으로 공개주소법은 분리 연결법보다 느리다. 공개 주소법의 경우 해시 버킷을 채운 밀도가 높아질수록 최악의 경우 발생 빈도가 높아지기 때문이다. 반면 분리 연결법은 해시 충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 조절할 수 있다면 최악의 경우에 가까워지는 빈도를 줄일 수 있다. 자바 7 에서는 분리 연결법을 사용해 HashMap을 구현하고 있다. (공개 주소법은 데이터를 삭제할 때 처리가 효율적이지 않은데 해시맵에서 remove()메소드는 매우 빈번하게 호출될 수 있기 때문이다.)분리 연결법은 두가지 구현 방식이 존재한다.
    1. **연결리스트 사용하는 방식:** 각각의 버킷들을 연결리스트로 만들어 충돌이 발생하면 해당 버킷의 리스트에 추가하는 방식이다. 연결리스트의 특징을 이어받아 삭제 또는 삽입이 간단하다. 
    2. **트리를 사용하는 방식:** 연결리스트 대신 트리를 사용하는 방식. 연결리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 키-값 쌍의 개수이다. 데이터의 개수가 적다면 연결리스트를 사용하는 것이 맞다. 트리는 기본적으로 메모리 사용량이 많기 때문이다. 데이터 개수가 적을 때 최악의 경우를 살펴보면 트리와 링크드 리스트의 성능 상 차이가 거의 없다.

### Open Address vs Separate Chaining

일단 두 방식 모두 최악의 경우에서 O(m)이다. 하지만 공개 주소법은 연속된 공간에 데이터를 저장하기 때문에 분리 연결법에 비해 캐시 효율이 높다. 하지만 배열의 크기가 커질수록(m 값이 커질수록) 캐시 적중률이 낮아져 캐시 효율이라는 공개주소법의 장점이 사라진다. 따라서 데이터의 개수가 충분히 적다면 공개주소법이 더 성능이 좋다. 공개주소법은 분리연결법에 비해 버킷을 계속해서 사용한다. 따라서 분리 연결법 방식은 테이블의 확장을 보다 늦출 수 있다.

### 보조 해시 함수

보조 해시 함수의 목적은 키의 해시 값을 변형하여 충돌 가능성을 줄이는 것이다. 분리 연결법을 사용할때 함께 사용되며 보조 해시 함수로 최악의 경우에 가까워지는 경우를 줄일 수 있다.

### 해시 버킷 동적 확장

해시 버킷의 개수가 적다면 메모리 사용을 아낄수 있지만 해시 충돌로 인해 성능 상 손실이 발생한다. 그래서 해시맵은 키-값 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두 배로 늘린다. 이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느정도 해결할 수 있다. 해시 버킷 크기를 두배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75퍼센트가 될 때이다. 

[https://d2.naver.com/helloworld/831311](https://d2.naver.com/helloworld/831311)

# 해시, 해시함수(해시 펑션), 해싱

**해시**란 데이터를 다루는 기법 중 하나이며, **해시 함수**는 데이터를 효율적으로 관리하기 위해 임의으이 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 

매핑 전 원래 데이터의 값을 **키**, 매핑 후 데이터의 값을 **해시값 또는 해시코드** 라고 하며, 키와 값으로 매핑되는 과정 자체를 **해싱**이라고한다.

## 해시 테이블

해시 테이블은 키와 값이 하나의 쌍을 이루는 데이터 구조이다. 키와 배열의 인덱스를 이용하여 키를 저장하는 자료구조이다. 해시 테이블은 해시맵, 맵, 딕셔너리, 연관 배열이라는 이름으로 알려져있다.

해시 테이블은 키를 해시 함수로 계산하여 그 값을 배열의 인덱스로 사용한다. 이 때 해시 함수에 의해 반환된 데이터의 고유 숫자값을 해시값 또는 해시코드라고 한다. 즉, 키 값을 해시함수를 통해 배열의 인덱스로 바꿔주고 그 자리에 데이터를 저장한다.

![Untitled](/image/dataStructure/Untitled4.png)

해시 테이블은 키, 해시함수, 해시, 값, 해시 버킷으로 이루어져있다.

**예시**

이름을 키로 하여 번호를 저장하는 해시 테이블

![Untitled](/image/dataStructure/Untitled5.png)

전체 데이터 양을 10이라고 하면 John의 데이터를 저장할 때 배열의 인덱스는 

해시 함수(”John”)%10을 통해 인덱스 값을 계산한다. 여기서는 2이다.

이런식으로 데이터를 저장하다 보면 계산된 인덱스 값이 중복될 수 있다. 예를 들어 저장하고자하는 키가 정수이고 해시 함수가 key%10이라면 전체 사이즈가 10일 때 key 1,11,21은 같은 인덱스값을 가지게 된다. 이를 충돌이라고 한다.

### 충돌

서로 다른 문자열이 해시 함수를 통해 해시한 결과가 같은 경우(중복)이다.

충돌을 줄여주는 좋은 해시 함수를 사용하는 것이 좋다. 왜냐하면 충돌이 많아질 수록 탐색의 시간복잡도가 O(1)에서 O(n)에 가까워지기 때문이다. 해결방법은 Separate Chaining(분리 연결법), Open Addressing(공개 주소법)이 있다.

### Separate Chaining

이 방법은 JDK 내부에서도 사용하는 충돌 처리 방식인데 연결 리스트나 트리를 사용하기도 한다.

두 개를 사용하는 기준은 데이터가 6개 이하이면 연결리스트를 사용하고 8개 이상이면 트리를 사용한다. 7개일때 데이터를 삭제하면 연결리스트로 바꿔야하고 추가되면 트리로 바꿔야하는데 바꾸는데 오버헤드가 있기 때문에 기준이 6,8이다)

![Untitled](/image/dataStructure/Untitled6.png)

다음은 연결 리스트를 사용한 것이다. 인덱스가 충돌이 날 때 인덱스가 가리키고 있는 연결 리스트에 노드를 추가하여 값을 삽입한다. 데이터를 탐색할 때는 키에 대한 인덱스가 가리키고 있는 연결 리스트를 선형 검색하여 해당 키에 대한 데이터를 반환한다. 삭제하는 것도 비슷하게 키에 대한 인덱스가 가리키고 있는 연결리스트에서 그 노드를 삭제한다.

**Separate Chaining의 장단점**

- 장점
    - 한정된 버킷을 효율적으로 사용할 수 있다.
    - 해시 함술르 선택하는 중요성이 상대적으로 적다.
    - 상대적으로 적은 메모리를 사용한다. 미리 공간을 잡아 놓을 필요가 없다.
- 단점
    - 한 해시에 자료들이 계속 연결된다면(쏠림현상) 검색 효율이 낮아진다.
    - 외부 저장 공간을 사용해야 한다.
    - 외부 저장 공간 작업을 추가로 해야한다.

### Open Addressing

이 방법은 인덱스에 대한 충돌 처리에 대해서 연결 리스트와 같은 추가적인 메모리 공간을 사용하지 않고 해시 테이블 array의 빈 공간을 사용하는 방법이다. 추가적인 메모리 공간을 사용하지 않기 때문에 Separate Chaining에 비해 메모리를 덜 사용한다. Linear Probing, Quadratic Probing, Double hashing 등이 있다. 그 중 Linear Probing은 다음과 같다.

![Untitled](/image/dataStructure/Untitled7.png)

인덱스가 중복되는 충돌이 발생할 때 인덱스 뒤에 있는 버킷중에 빈 버킷을 찾아서 데이터를 넣는다. 그림에서 산드라(키)의 인덱스는 152이다. 하지만 John과 충돌이 나기 때문에 그 다음 인덱스인 153에 데이터를 넣는다. 여기서 산드라에 대해 검색을 하면 인덱스가 152라서 키가 일치하지 않기 때문에 뒤의 인덱스를 검색해 같은 키가 나오거나 키가 없을 때까지 검색을 진행한다. 삭제는 더미 노드를 넣어서 검색할 때 다음 인덱스까지 검색을 연결해주는 역할을 해줘야 한다(삭제가 어렵다)

**Open Addressing의 장단점**

- 장점
    - 또 다른 저장 공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능하다
    - 또 다른 저장 공간에서의 추가적인 작업이 없다.
- 단점
    - 해시 함수의 성능에 전체 해시테이블의 성능이 좌우된다.
    - 데이터의 길이가 늘어나면 그에 해당하는 버킷을 마련해 두어야 한다.

### Resizing

Separate Chaining의 경우 버킷이 일정 수준으로 차버리면 각 버킷에 연결되어 있는 리스트의 길이가 늘어나기 때문에 검색 성능이 떨어지지 않도록 버킷의 개수를 늘려줘야 한다. 또한 Open Addressing의 경우 고정 크기 배열을 사용하기 때문에 데이터를 더 넣기 위해서는 배열을 확장해야한다. 이를 리사이징이라한다.

보통 두배로 확장하는데 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 75퍼센트가 될 때이다.

리사이징은 더 큰 버킷을 가지는 Array를 새로 만들고 해시를 다시 계산해서 복사해줘야한다.

### 해시 테이블의 장점

- 적은 리소스로 많은 데이터를 효율적으로 관리 할 수 있다.
    - 하드디스크 ,클라우드에 존재하는 많은 데이터들을 유한한 개의 해시 값으로 매핑하여 작은 크기의 캐시 메모리로 프로세스 관리가 가능하다.
- 배열의 인덱스를 사용해서 검색, 삽입, 삭제가 빠르다 (평균 시간 복잡도 : O(1)
    - 인덱스를 사용해 검색이 빠른건 알겠는데 왜 삽입 삭제가 O(1)인가?
    - 여기서 인덱스는 데이터만의 고유한 위치기 때문에 삽입이나 삭제를 한다고 해도 다른 데이터로 채울 필요가 없다. 즉, 삽입이나 삭제할 때 데이터를 이동할 필요가 없기 때문이다.
- 키와 해시값이 연관성이 없어 보안에도 많이 사용된다.
- 데이터 캐싱에 많이 사용된다.
    - get(key), put(key)에 캐시 로직을 추가하면 자주 hit하는 데이터를 바로 찾을 수 있다.
- 중복을 제거하는데 유용하다.

### 해시 테이블의 단점

- 충돌
- 공간 복잡도가 커진다( 데이터가 저장되기 전에 미리 저장공간을 확보해야 한다.)
- 순서가 있는 배열에는 어울리지 않는다.
- 해시 함수 의존도가 높아진다. (평균 데이터 처리 시간복잡도가 O(1)이지만 이는 해시 함수의 연산을 고려하지 않은 결과이다. 해시함수가 매우 복잡하다면 해시테이블의 모든 연산은 시간복잡도가 낮아질 것이다)

### 해시 테이블의 성능

키값이 배열의 인덱스로 변환되기 때문에 탐색, 삽입, 삭제가 빠르다. 평균 시간복잡도가 O(1)이다. 평균 시간 복잡도인 이유는 충돌 때문이다.

![Untitled](/image/dataStructure/Untitled8.png)

### 해시 테이블 vs 해시 맵

자바에서 해시 테이블과 해시 맵의 차이는 동기화 여부이다. 키에 대한 해시값을 사용해 값을 저장, 조회 하는 것은 동일하다.

- 해시 테이블 : 병렬 처리를 할때(동기화를 고려해야 하는 상황), 널 값을 허용하지 않는다.
- 해시  맵: 병렬 처리를 하지 않을 때(동기화 고려하지 않는 상황), 널 값을 허용한다.

[https://hee96-story.tistory.com/48](https://hee96-story.tistory.com/48)

[https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table해시-해싱-해시테이블-자료구조의-이해-6ijyonph6o](https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o)

# 자료구조 별 시간 복잡도

![Untitled](/image/dataStructure/Untitled9.png)
