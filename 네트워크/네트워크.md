# 네트워크

[이석복 교수님 강의 정리](https://www.notion.so/185079b5cf9345db981f449cb33eb3c0)

# TCP/UDP 차이

### 공통점

- 데이터 전달을 담당하는 전송계층의 프로토콜이다.

### TCP

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled.png)

- 일반적으로 TCP와 IP를 함께 사용한다. IP가 데이터의 배달을 처리한다면 TCP는 패킷(인터넷 내에서 데이터를 보내기 위한 경로배정(라우팅)을 효율적으로 하기 위해 데이터를 여러개의 조각들로 나누어 전송하는데 이 조각을 패킷이라 한다.)을 추적 및 관리한다.
- 연결형 서비스를 지원하는 프로토콜로 인터넷 환경에서 기본으로 사용한다.
- 연속성보다 신뢰성 있는 전송이 중요할 때 사용(예를들면 파일 전송)
- 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정하는 가상회선 방식을 제공한다.
- 3-way handshaking(목적지와 수신지를 확실히 하여 정확한 전송을 보장하기 위해 세션을 수립하는 과정)을 통해 연결하고 4-way handshaking을 통해 해제한다.
- 흐름제어 및 혼잡제어
- 높은 신뢰성 보장
- 전이중(full-duplex, 전송이 양방향으로 동시에 일어날 수 있다.), 점대점(Point to Point, 연결이 정확히 2개의 종단을 가지고 있다.) 방식
- TCP 위에서 동작되는 프로토콜 : HTTP, 이메일?

### TCP 서버의 특징

- 서버 소켓은 연결만을 담당한다.
- 연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다.
- 스트림 전송으로 전송 데이터의 크기가 무제한이다.
- 패킷에 대한 응답을 해야하기 때문에 성능이 낮다(시간 지연, CPU 소모)
- 서버와 클라이언트가 1:1로 연결된다.

### UDP

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%201.png)

- 신뢰성보다 연속성이 중요한 서비스에 사용(스트리밍 서비스)
- 비연결형 서비스(연결을 위해 할당되는 논리적인 경로가 없다.)로 데이터 그램(독립적인 관계를 지니는 패킷) 방식
- 각각의 패킷이 독립적이기 때문에 다른 경로로 전송된다.
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차가 없다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출
- 신뢰성 낮다(데이터의 전송을 보장하지 못함.)
- TCP보다 빠르고 네트워크 부하가 적다는 장점이 있다.
- UDP 위에서 동작되는 프로토콜 : TFTP, SNMP, DHCP, DNS, RIP 등

### UDP 서버의 특징

- UDP에는 연결자체가 없어서 서버 소켓과 클라이언트 소켓의 구분이 없다.
- 소켓 대신 IP를 기반으로 데이터를 전송한다.
- 서버와 클라이언트는 1대1, 1대N, N대M으로 연결될 수 있다.
- 데이터 그램 단위로 전송되며 그 크기는 65535바이트로 크기가 초과하면 잘라서 보낸다.
- 흐름제어가 없어서 패킷이 제대로 전송되었는지 오류가 없는지 확인할 수 없다.
- 파일전송과 같은 신뢰성이 필요한 서비스 보다 성능이 중요시 되는 경우에 사용된다.

### 소켓

- TCP/IP를 이용하는 API. 소프트웨어로 작성된 통신의 접속점이다.
- 애플리케이션은 소켓을 통해 네트워크와 패킷을 주고 받을 수 있다.

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%202.png)

|  | TCP | UDP |
| --- | --- | --- |
| 연결방식 | 연결형 서비스 | 비연결형 서비스 |
| 패킷 교환 방식 | 가상 회선 방식 | 데이터 그램 |
| 전송 순서 | 전송 순서 보장 | 전송 순서 바뀔 수 있다. |
| 수신 여부 확인 | 수신 여부 확인 | 확인 안함 |
| 통신 방식 | 1:1 | 1:1, 1:N, N;M |
| 신뢰성 | 높다 | 낮다 |
| 속도 | 느리다 | 빠르다 |

[https://mangkyu.tistory.com/15](https://mangkyu.tistory.com/15)

# TCP ACK의 두가지 방법

TCP가 패킷을 하나씩만 전송하지는 않는다. 슬라이딩 윈도우를 사용해 보낼 수 있는 만큼 연속으로 계속 보낸다. 이 때 가운데 패킷이 유실된 경우는 어떻게 될까. TCP의 기본 동작은 뭔가 유실되면 그 뒤에 아무리 정상적으로 와도 다 버리고 유실된 것부터 재전송한다. 

cumulative ACK는 앞의 것은 다 받았고 여기부터 다시 보내줘라는 뜻이다.

selective ACK는 받았는지 여부를 선택적으로 알려준다.

cumulative ACK는 여러개의 패킷을 보냈다고 하더라도 문제가 되는 ACK 하나만 기억하면되는 반면 selective ACK는 여러개 패킷에 대해서 각각 ACK를 받았는지를 모두 기억해야 한다. cumulative ACK는 기억해야 하는 것도 적고 구현도 간단한 반면 selective ACK는 기억해야 하는 것도 많고 구현도 복잡해진다.

초기의 TCP는 cumulative ACK를 기반으로 했다. 그런데 뒤의 것을 다 버리다 보니 비 효율적이고 이런 비효율성은 IP가 패킷을 많이 까먹을 수록 급속도로 비효율적으로 변하기 시작했다. 예를 들어 무선통신에서의 IP라면 까먹는 것도 많을 테니 TCP는 상당히 많은 양을 재전송 해야한다. 그리고 이것은 사용자 입장에서 매우 느리다고 느끼게 된다.

통신망이 10% 불안정해지면 속도가 10%를 까먹는 것이 아니라 몇 배이상 속도가 안나게 된다. 그때문에 나중에는 selective ACK를 TCP의 옵션으로 채택했다. 그리고 보내는 쪽과 받는 쪽 모두 ‘나 selective ACK 할 줄 아는데’ 라고 해야만 동작한다. 

[https://www.inven.co.kr/webzine/news/?news=165870](https://www.inven.co.kr/webzine/news/?news=165870)

# TCP 세그먼트 구조

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%203.png)

응용 계층으로부터 데이터를 받은 TCP는 헤더를 추가한 후에 이를 IP로 보낸다.

헤더에 포함되는 정보

- 송 수신자의 포트번호 : TCP로 연결되는 가상 회선 양단의 송수신 프로세스에 할당되는 포트 주소
- 시퀀스 번호 : 송신자가 지정하는 순서 번호, 전송되는 바이트 수를 기준으로 증가. SYN=1 : 초기 시퀀스 번호가 된다. ACK 번호는 이 값에 1을 더한 값. SYN=0 : 현재 세션의 이 세그먼트 데이터의 최초 바이트 값의 누적 시퀀스 번호
- 응답 번호(ACK Number) : 수신 프로세스가 제대로 수신한 바이트의 수를 응답하기 위해 사용.  수신하기를 기대하는 다음 바이트 번호를 보낸다.(마지막 수신 성공 번호+1)
- 데이터 오프셋: TCP 세그먼트의 시작 위치를 기준으로 데이터의 시작 위치를 표현(TCP 헤더의 크기)
- 예약 필드 : 사용을 하지 않지만 나중을 위한 예약 필드이며 0으로 채워져야 한다.
- 제어 비트 : SYN, ACK, FIN 등. TCP 세그먼트 전달과 관련되어 TCP 회선 및 데이터 관리 제어기능을 하는 플래그.
- 윈도우 크기 : 수신 윈도우의 버퍼 크기를 지정할 때 사용. 0이면 송신 프로세스의 전송 중지. 흐름 제어를 위해 사용한다. TCP 흐름제어를 위해 통신의 상대편에게 자신의 버퍼 여유용량 크기를 지속적으로 통보하는 기능.
- 체크섬: 헤더와 데이터에 대한 오류 검출 용도
- 긴급 위치: 긴급 데이터를 처리하기 위함, URG 플래그 비트가 지정된 경우에만 유효

### 제어 비트 정보

- URG : 긴급 위치를 필드가 유효한지 설정
- ACK : 응답 번호 필드가 유효한지 설정. 클라이언트가 보낸 최초의 SYN 패킷 이후에 전송되는 모든 패킷은 이 플래그가 설정되어야 한다.
- PSH : 수신 애플리케이션에 버퍼링된 데이터를 상위 계층에 즉시 전달할 때
- RST : 연결의 리셋이나 유효하지 않은 세그먼트에 대한 응답용
- SYN : 연결 설정 요구, 시퀀스 번호를 보낸다, 양쪽이 보낸 최초의 패킷에만 이 플래그가 설정되어 있어야 한다.
- FIN : 더이상 전송할 데이터가 없을 때 연결 종료 의사 표시

### UDP 헤더 정보

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%204.png)

- 송신 포트번호 : 데이터를 보내는 애플리케이션의 포트 번호
- 수신 포트번호 : 데이터를 받을 애플리케이션의 포트 번호
- 데이터의 길이: UDP 헤더와 데이터의 총 길이
- 체크섬 : 데이터 오류 검사에 사용

[https://velog.io/@hidaehyunlee/TCP-와-UDP-의-차이](https://velog.io/@hidaehyunlee/TCP-%EC%99%80-UDP-%EC%9D%98-%EC%B0%A8%EC%9D%B4)

# OSI 7 Layer

- OSI 7 Layer란 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약으로 다음과 같이 분류된다.
- 물리 계층: 전송하는데 필요한 기능을 제공, 장비로는 통신 케이블, 허브가 존재한다.
- 데이터링크 계층: 송/수신을 확인. Mac address를 가지고 통신. 장비로는 브릿지와 스위치가 존재한다.
- 네트워크 계층: 패킷을 네트워크 간의 IP를 통하여 데이터를 전달. 장비로는 라우트가 존재한다.
- 전송 계층: 두 호스트 시스템으로부터 발생하는 데이터의 흐름을 제공한다.
- 세션 계층: 통신 시스템 사용자간의 연결을 유지 및 설정한다.
- 표현 계층: 세션 계층 간의 주고받는 인터페이스를 일관성 있게 제공한다.
- 응용 게층: 사용자가 네트워크에 접근할 수 있도록 서비스를 제공한다.

# OSI 7 Layer

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%205.png)

- 국제 표준화 기구에서 개발한 모델로 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것
- 이 모델은 프로토콜을 기능별로 나눈 것이다.
- 각 계층은 하위 계층의 기능만을 이용하고 상위 계층에게 기능을 제공한다.
- 프로토콜 스택은 이러한 계층들로 구성되는 프로토콜 시스템이 구현된 시스템을 가리키는데, 프로토콜 스택은 하드웨어나 소프트웨어 혹은 둘의 혼합으로 구현될 수 있다.
- 일반적으로 하위 계층들은 하드웨어로 상위 계층은 소프트웨어로 구현된다.
1. 물리 계층
    - 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다.
    - 전송 단위는 bit이다.
2. 데이터 링크 계층
    - 포인트 투 포인트 간 신뢰성 있는 전송을 보장하기 위한 계층으로 CRC 기반의 오류제어와 흐름제어가 필요하다.
    - 주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥주소가 정해져있다는 뜻이다.
    - 데이터 링크 계층의 가장 잘 알려진 예는 이더넷이다.
    - 데이터 전송 단위는 프레임이다.
3. 네트워크 계층
    - 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층으로 다양한 길이의 데이터를 네트워크를 통해 전달하고 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)를 제공하기 위한 기능적, 절차적 수단을 제공한다.
    - 네트워크 계층은 라우팅, 흐름제어, 세그멘테이션, 오류제어, 인터네트워킹 등을 수행한다.
    - 논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며 계층적이다.
    - 데이터 전송단위는 패킷이다.
4. 전송 계층
    - 양 끝단(End to End)의 사용자들이 신뢰성 있는 데이터를 주고 받을 수 있도록 해주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.
    - 시퀀스 넘버 기반의 오류 제어 방식을 사용한다.
    - 전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념(stateful)이 있고 연결 기반이다.(이는 전송 계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것을 뜻한다.)
    - TCP,UDP
    - 데이터 전송 단위는 세그먼트이다.
5. 세션 계층
    - 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
    - 동시 송수신 방식(duplex), 반이중방식(half-duplex), 전이중방식(full-duplex)의 통신과 함께 체크 포인팅과 유휴,종료,다시 시작 과정 등을 수행한다.
    - 이 계층은 TCP/IP 세션을 만들고 없애는 책임을 진다.
6. 표현 계층
    - 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어준다.
    - MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.
7. 응용 계층
    - 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.
    - 일반적인 응용 서비스는 관련된 응용 프로세스들 사이의 전환을 제공한다.

# Restful API

### REST

- HTTP URI를 통해 자원을 명시하고, HTTP Method를 통해 자원에 대한 CRUD를 적용하는 것
- 자원(URI)+행위(HTTP method)+표현
- 자원: client는 URI를 이용해서 자원을 지정하고 해당 자원에 대한 조작을 server에 요청
- 행위 : GET, POST, PUT, DELETE
- 표현: JSON, XML을 통해 데이터를 주고 받는 것이 일반적이다.

### API

- 데이터와 기능의 집합을 제공하여 컴퓨터 프로그램 간 상호작용하고 서로 데이터 교환을 가능하게 하는 것

### Rest API

- REST 기반으로 서비스 API를 구현하는 것

### RESTful

- REST원리를 따르는 시스템을 RESTful이라고 지칭한다.

[https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html](https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html)

# 3-way handshaking

- client와 server 사이에 논리적인 접속을 성립하기 위해 사용
- TCP/IP 프로토콜을 이용해서 통신하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정
- client와 server 모두 데이터를 전송할 준비가 되었다는 것을 보장

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%206.png)

클라이언트 → 서버 : SYN

- 클라이언트가 서버한테 연결 요청 메세지 전송(SYN)
- 송신자가 최초로 데이터를 전송할 때 sequence number를 임의의 랜덤 숫자로 지정하고 SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
- 포트 상태: 서버-Listen, 클라이언트-Closed

서버 → 클라이언트 : SYN+ACK

- 접속 요청을 받은 서버가 요청을 수락하고 클라이언트한테 포트를 열어달라는 메세지 전송(SYN+ACK)
- 서버는 ACK number 필드를 sequence number+1로 지정하고 SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
- 포트 상태: 서버-SYN_RCV, 클라이언트-Closed

클라이언트 → 서버 : ACK

- 포트상태 : 서버-SYN_RCV, 클라이언트-Established
- 마지막으로 클라이언트가 수락 확인을 보내 연결을 맺는다.(ACK)
- 전송할 데이터가 있다면 이때 같이 보낸다.
- 포트상태 : 서버-Established, 클라이언트-Established

### 초기 sequence number를 랜덤으로 지정하는 이유?

connection을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용할 가능성이 있다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하는데 난수가 아닌 순차적인 number를 쓴다면 이전 connection으로부터 오는 패킷으로 인식할 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해 난수로 설정한다.

# 4-way handshake

- TCP 연결 해제 할 때
- 한단계 더 있는 이유 : 클라이언트가 데이터 전송을 마쳤다고 하더라도 서버가 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 먼저 보내고 데이터를 모두 전송한 후에 자신도 FIN 메세지를 보내기 때문이다.
- 연결 끝내도 조금 더 기다림 (엣지 케이스 대비)

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%207.png)

클라이언트 → 서버 : FIN

- 클라이언트가 연결을 종료하겠다는 FIN 플래그 전송
- 서버가 FIN 플래그로 응답하기 전까지 연결을 유지하고 있다.

서버 → 클라이언트 : ACK

- 서버는 일단 ACK로 응답하고 자신의 통신이 끝날 때까지 기다린다.(Close_Wait 상태)
- 서버는 ACK 필드를 sequence number+1로 지정하고 ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
- 전송할 데이터가 남았다면 이어서 전송한다.

서버 → 클라이언트 : FIN

- 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 FIN 플래그 전송

클라이언트 → 서버 : ACK

- 확인했다는 메시지 전송
- 클라이언트는 Time_Wait 상태가 된다.
- 서버로부터 FIN을 수신하더라도 일정시간 동안(보통 타이머 시간) 세션을 남겨놓고 패킷을 기다린다(엣지케이스 대비). 타이머가 끝나면 연결 종료

# TCP 혼잡제어

- 네트워크 체증을 막기 위해 한번에 보낼 수 있는 패킷 개수가 정해져 있다. 처음에는 적은 숫자를 보내고 유실이 없으면 숫자를 늘려나간다. 그 때문에 TCP는 유실이 없다고 하더라도 한번에 보낼 수 있는 패킷 개수 제한 때문에 느리다.
- 슬로우 스타트로 MSS(맥시멈 세그먼트 사이즈, 윈도우 사이즈) 늘려감 (2배씩)
- 임계치(쓰레시 홀드)에 오면 선형 증가(조심스럽게 올림)
- 패킷 로스 나면 네트워크 혼잡한 상태로 인식하고 임계치를 패킷 로스 난 시점의 MSS의 절반으로 줄임
- 그럼 네트워크 원할해질테니 다시 MSS 확 낮추고 슬로우 스타트⇒반복
- 흐름제어는 애크세그먼트 헤더에 리시브 윈도우를 알려주니 얼마만큼 받을 수 있는지를 알아서 직관적으로 할 수 있지만 네트워크 상태는 알 방법이 없으니 이런식으로 진행하는 것

# TCP reno

- TCP Tahoe(첫번째 버전)의 다음 버전
- 패킷 로스라고 판단하는 경우는 두가지 경우가 있는데 첫번째는 타이머가 터진경우(타임 아웃) 두번째는 세개의 중복된 애크가 왔을경우
- 세개의 중복된 애크가 온 경우는 하나의 패킷만 로스되고 그 뒤의 패킷들은 정상적으로 리시버에게 도착한거다. 그러므로 네트워크가 혼잡한거는 아닐텐데라고 판단
- 그래서 두가지 경우에 따라 MSS를 다르게 떨어뜨린다.
- 타이머가 터진경우는 그 뒤의 패킷들도 제대로 도착을 안한거니 네트워크가 진짜 혼잡하다고 판단해서 임계치를 MSS의 절반으로 줄이고 MSS를 확 낮춘채로 다시 슬로우 스타트부터 반복하는 반면
- 세개의 중복된 애크가 온 경우는 네트워크가 혼잡하다고 판단하긴 애매해서 임계치를 MSS의 절반으로 줄이고  MSS는 확 낮추는게 아니라 임계치부터 시작(슬로우 스타트부터 말고 선형증가로)

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%208.png)

# HTTP와 HTTPS

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%209.png)

### HTTP

- HTTP는 인터넷에서 웹 서버와 사용자 측의 웹 브라우저 사이에 문서를 전송하기 위한 프로토콜
- 인터넷에서 HyperText를 전송하기 위해 사용하는 프로토콜
- TCP,UDP 사용가능(거의 TCP 사용)
- 80번 포트 사용한다.
- 비연결(connectionless, 클라이언트가 서버에 요청을 보내고 서버가 적절한 응답을 하면 연결이 끊긴다. 연결을 유지하지 않는다.), 무상태(stateless, 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다.)의 특징을 가지고 있다.
- 클라이언트와 서버가 계속 연결된 형태가 아니기 때문에 클라이언트와 서버 간의 최대 연결 수보다 훨씬 많은 요청과 응답을 처리할 수 있다.
- 상태 정보를 유지하지 않기 때문에 클라이언트의 이전 상황을 알 수가 없다. ⇒ 이런 특징때문에 정보를 유지하기 위해 Cookie와 같은 기술이 등장하게 되었다.

### HTTP의 문제점

- HTTP는 정보를 단순 텍스트로 주고 받기 때문에 (암호화X) 네트워크 상에서 전송신호를 인터셉트하는 경우 데이터 유출이 발생할 수 있다.

### HTTPS

- 보안이 강화된 HTTP
- 443번 포트 사용.
- 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.
- SSL이나 TLS 프로토콜을 사용하여 데이터를 암호화 한다.
- HTTPS는 초기에 클라이언트, 서버가 통신을 하며 암호화 키를 서로 안전하게 주고 받는다.(SSL HandShake)
- 이 때 암호화 키값이 노출되지 않도록 안전하게 해주는게 Https 서버 인증서이다.
- SSL(보안 소켓 계층)을 사용함으로써 서버와 브라우저 사이에 안전하게 암호화된 연결을 만든다.
- TLS(전송 계층 보안) 프로토콜을 통해서도 보안을 유지한다.
- TLS는 데이터 무결성을 제공하기 때문에 데이터가 전송 중에 수정, 손상되는것을 방지한다.

### HTTPS 원리

- 공개키 알고리즘 방식
- 암호화, 복호화시킬 수 있는 서로 다른 키를 이용한 암호화 방법
    - 공개키 : 모두에게 공개, 공개키 저장소에 등록
    - 개인키(비공개키) : 개인에게만 공개. 클라이언트-서버 구조에서는 서버가 가지고 있는 비공개키
- 클라이언트→서버
    - 사용자의 데이터를 공개키로 암호화(공개키를 얻은 인증된 사용자)
    - 서버로 전송 (데이터를 가로채도 개인키가 없으므로 복호화할 수 없다.)
    - 서버의 개인키를 통해 복호화하여 요청을 처리한다.

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%2010.png)

### HTTP와 HTTPS의 장단점

사용자 입장

- HTTP는 HTTPS에 비해 빠르다.
- HTTP는 변조 가능성을 항상 가지고 있다.
- HTTPS는 네트워크 상에서 열람, 수정이 불가하므로 인터넷을 이용하는데 안전하다.

사용자 입장에서는 보안이 뛰어난 HTTPS를 이용하는 것이 이득이다.

공급자 입장

- HTTP로 민감한 정보를 다룰 때 변조나 해킹 가능성을 생각해야한다.
- HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 든다.
- HTTP는 HTTPS보다 트래픽이 적게 발생한다. 즉, HTTP는 상대적으로 적은 비용으로 유지 가능하다.

공급자 입장에서는 민감한 정보가 없는 페이지는 HTTP를 이용하고 로그인, 결제 시스템 등과 같이 민감한 정보가 필요한 페이지는 HTTPS를 사용하는 것이 합리적이다.

[https://wayhome25.github.io/cs/2018/03/11/ssl-https/](https://wayhome25.github.io/cs/2018/03/11/ssl-https/)

[https://opentutorials.org/course/228/4894](https://opentutorials.org/course/228/4894)

# SSL

- 보안 소켓 계층(SECURE SOCKETS LAYER)
- 웹 서버와 브라우저 사이에 전송되는 데이터를 암호화하여 인터넷 연결을 보호하기 위한 표준 기술. 해커가 개인 데이터나 금융 데이터 등의 정보를 보거나 훔치는 것을 방지한다.
- HTTP의 보안 문제를 해결해준다. SSL이 적용되어 HTTPS라고 칭한다.

### SSL 인증서

- 클라이언트와 서버간의 통신을 공인된 제 3자(CA) 업체가 보증해주는 전자화된 문서

### SSL 인증서의 장점 및 역할

- 통신 내용이 노출, 변경되는 것을 방지
- 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지 확인 가능하다.
- SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.

### SSL 인증서 내용

- 인증서 내용은 CA의 비공개 키를 이용해서 암호화 되어 웹브라우저에게 제공된다.
- 서비스 정보(인증서 발급자, CA의 디지털 서명, 서비스 도메인), 서버측 공개키

### SSL 인증서의 서비스 보증 방법

- 웹브라우저가 서버에 접속하면 서버는 제일 먼저 인증서를 제공한다.
- 브라우저는 인증서를 발급한 CA가 자신이 갖고있는 CA리스트에 있는지 확인한다.
- 리스트에 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화한다.
- 인증서를 복호화 할수 있다는 것은 이 인증서가 CA의 비공개키에 의해서 암호화 된 것을 의미한다. 즉, 데이터를 제공한 사람의 신원을 보장해주는 것이다.

### SSL 동작

- 공개키 암호 방식은 알고리즘 계산방식이 느리다.
- 따라서 SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키 암호화 방식을 혼합하여 사용한다.
- 안전한 의사소통 채널을 수립할 때는 공개키 암호를 사용하고 이렇게 만들어진 안전한 채널을 통해서 임시의 무작위 대칭키를 생성 및 교환한다. 해당 대칭키는 나머지 데이터 암호화에 활용한다.
- 실제 데이터 암호화 방식: 대칭키, 상기 대칭키를 서로 공유하기 위한 암호화 방식: 공개키
- 동작
    - 서버 측에서 CA(인증 기관)에 사이트정보+공개키를 주고 인증서를 요청한다.
    - CA에서 심사완료 후 사이트정보+공개키를 개인키로 암호화하고 공개키를 브라우저에 등록
    - 브라우저가 서버에 인증서를 요청한다.
    - 인증서가 CA에서 인증받은 것인지 브라우저가 확인하고 공개키를 이용해 서버측 사이트 정보+공개키를 획득한다.
    - 클라이언트의 대칭키를 서버측의 공개키로 암호화해서 서버에게 전송한다.
    - 서버는 자신의 개인키로 복호화하여 클라이언트 측의 대칭키를 획득 ⇒ 대칭키는 클라이언트, 서버만 갖게 된다.
    - 이 대칭키로 암호화, 복호화 하여 통신한다.

[https://wayhome25.github.io/cs/2018/03/11/ssl-https/](https://wayhome25.github.io/cs/2018/03/11/ssl-https/)

[https://www.digicert.com/kr/what-is-ssl-tls-and-https](https://www.digicert.com/kr/what-is-ssl-tls-and-https)

# HTTP와 HTTPS 동작 과정

### HTTP

서버 접속 → 클라이언트 → 요청 → 서버 → 응답 → 클라이언트 → 연결 종료

1. 사용자가 웹 브라우저에 서버 URL 입력
2. DNS 서버에 웹 서버의 호스트 이름을 IP 주소로 변경 요청
3. 웹 서버와 TCP 연결 시도(3-way handshaking)
4. 클라이언트가 서버에게 요청
    - HTTP Request Message = RequestHeader+빈줄+RequestBody
    - RequestHeader
        - 요청 메소드+ 요청 URI + HTTP 프로토콜 버전
        - ex) GET / background.png / HTTP 1.0, POST / HTTP 1.1
        - Header 정보(key-value 구조)
    - 빈 줄
        - 요청에 대한 모든 메타 정보가 전송되었음을 알리는 용도
    - RequestBody
        - GET, HEAD, DELETE, OPTIONS처럼 리소스를 가져오는 요청은 바디 미포함(POST, PUT만 존재)
        - 데이터 업데이트 요청과 관련된 내용
5. 서버가 클라이언트에게 응답
    - HTTP Response Message = ResponseHeader + 빈줄 + ResponseBody
    - ResponseHeader
        - HTTP 프로토콜 버전+응답코드+응답메시지
        - ex) HTTP/1.1 404 Not Found
        - Header 정보(key-value 구조). 날짜,웹서버 이름, 콘텐츠 타입, 캐시 제어 방식 등
    - 빈줄
        - 요청에 대한 모든 메타 정보가 전송되었음을 알리는 용도
    - ResponseBody
        - 응답 리소스 데이터 (201,204 상태 코드는 바디 미포함)
6. 서버 클라이언트 간 연결 종료(4-way-handshaking)
7. 웹 브라우저가 문서 출력

### HTTPS

공개키 암호화 방식과 대칭키 암호화 방식의 장점을 활용해 하이브리드 사용

- 데이터를 대칭 키 방식으로 암호화,복호화 하고 공개키 방식으로 대칭키 전달한다.

1. 클라이언트가 서버 접속하여 Handshaking 과정에서 서로 탐색
    
    1-1. 클라이언트 Hello
    
    - 클라이언트가 서버에게 전송할 데이터
        - 클라이언트 측에서 생성한 랜덤 데이터
        - 클라이언트-서버 암호화 방식 통일 위해 클라이언트가 사용할 수 있는 암호화 방식
        - 이전에 이미 Handshaking 기록이 있다면 자원 절약을 위해 기존 세션을 재활용하기 위한 세션 아이디
    
    1-2. 서버 Hello
    
    - 클라이언트 hello에 대한 응답으로 전송할 데이터
        - 서버 측에서 생성한 랜덤 데이터
        - 서버가 선택한 클라이언트의 암호화 방식
        - SSL 인증서
    
    1-3. 클라이언트 인증 확인
    
    - 서버로부터 받은 인증서가 CA에 의해 발급되었는지 본인이 가지고 있는 목록에서 확인하고 목록에 있다면 CA 공개키로 인증서 복호화
    - 클라이언트-서버 각각의 랜덤 데이터를 조합하여 pre master secret 값 생성(데이터 송수신 시 대칭 키 암호화에 사용할 키)
    - pre master secret 값을 공개키 방식으로 서버에 전달(공개키는 서버로부터 받은 인증서에 포함)
    - 일련의 과정을 거쳐 session key 생성
    
    1-4. 서버 인증 확인
    
    - 서버는 비공개키로 복호화하여 pre master secret 값 취득(대칭키 공유 완료)
    - 일련의 과정을 거쳐 session key 생성
    
    1-5. Handshaking 종료
    
2. 데이터 전송
    
    서버와 클라이언트는 session key를 활용해 데이터를 암호화 복호화하며 데이터 송수신
    
3. 연결 종료 및 session key 폐기

[https://gmlwjd9405.github.io/2019/04/17/what-is-http-protocol.html](https://gmlwjd9405.github.io/2019/04/17/what-is-http-protocol.html)

[https://developer.mozilla.org/ko/docs/Web/HTTP/Messages](https://developer.mozilla.org/ko/docs/Web/HTTP/Messages)

# HTTP 요청 응답 헤더

- HTTP 헤더 내 일반 헤더(General Header) 항목
    - 요청 및 응답 메시지 모두에서 사용 가능한 일반 목적의(기본적인) 헤더 항목
    - 주요 항목들
        - **Date**: HTTP 메시지를 생성한 일시 (RFC 1123에서 규정)
            - `Date: Sat, 2 Oct 2018 02:00:12 GMT`
        - **Connection**: 클라이언트와 서버 간 연결에 대한 옵션 설정(다소 모호한 복잡성 있음)
            - `Connection: close` => 현재 HTTP 메시지 직후에 TCP 접속을 끊는다는 것을 알림
            - `Connection: Keep-Alive` => 현재 TCP 커넥션을 유지
        - **Cache-Control**
        - **Pragma**
        - **Trailer**
- HTTP 헤더 내 엔터티/개체 헤더 (Entity Header) 항목
    - 요청 및 응답 메시지 모두에서 사용 가능한 Entity(콘텐츠, 본문, 리소스 등)에 대한 설명 헤더
    - 주요 항목들
        - **Content-Type**: 해당 개체에 포함되는 미디어 타입 정보
            - 컨텐츠의 타입(MIME 미디어 타입) 및 문자 인코딩 방식(EUC-KR,UTF-8 등)을 지정
            - 타입 및 서브타입(type/subtype)으로 구성
            - `Content-Type: text/html; charset-latin-1` => 해당 개체가 html으로 표현된 텍스트 문서이고, iso-latin-1 문자 인코딩 방식으로 표현됨
        - **Content-Language**: 해당 개체와 가장 잘 어울리는 사용자 언어(자연언어)
        - **Content-Encoding**: 해당 개체 데이터의 압축 방식
            - `Content-Encoding: gzip, deflate`
            - 만일 압축이 시행되었다면, Content-Encoding 및 Content-Length 2개 항목을 토대로 압축 해제 가능
        - **Content-Length**: 전달되는 해당 개체의 바이트 길이 또는 크기(10진수)
            - 응답 메시지 Body의 길이를 지정하거나, 특정 지정된 개체의 길이를 지정함
        - **Content-Location**: 해당 개체가 실제 어디에 위치하는가를 알려줌
        - **Content-Disposition**: 응답 Body를 브라우저가 어떻게 표시해야 할지 알려주는 헤더
            - inline인 경우 웹페이지 화면에 표시되고, attachment인 경우 다운로드
            - `Content-Disposition: inline`
            - `Content-Disposition: attachment; filename='filename.csv'`
            - 다운로드되길 원하는 파일은 attachment로 값을 설정하고, filename 옵션으로 파일명까지 지정해줄 수 있다.
            - 파일용 서버인 경우 이 태그를 자주 사용
        - **Content-Security-Policy**: 다른 외부 파일들을 불러오는 경우, 차단할 소스와 불러올 소스를 명시
            - *XSS 공격*에 대한 방어 가능 (허용한 외부 소스만 지정 가능)
            - `Content-Security-Policy: default-src https:` => https를 통해서만 파일을 가져옴
            - `Content-Security-Policy: default-src 'self'` => 자신의 도메인의 파일들만 가져옴
            - `Content-Security-Policy: default-src 'none'` => 파일을 가져올 수 없음
        - **Location**: 리소스가 리다이렉트(redirect)된 때에 이동된 주소, 또는 새로 생성된 리소스 주소
            - 300번대 응답이나 201 Created 응답일 때 어느 페이지로 이동할지를 알려주는 헤더
            - 새로 생성된 경우에 HTTP 상태 코드 `201 Created`가 반환됨
            - `HTTP/1.1 302 Found Location: /`
                - 이런 응답이 왔다면 브라우저는 / 주소로 redirect한다.
        - **Last-Modified**: 리소스를 마지막으로 갱신한 일시
- HTTP 헤더 내 요청 헤더 (Request Header) 항목
    - 요청 헤더는 HTTP 요청 메시지 내에서만 나타나며 가장 방대하다.
    - 주요 항목들
        - **Host**: 요청하는 호스트에 대한 호스트명 및 포트번호 (***필수***)
            - Host 필드에 도메인명 및 호스트명 모두를 포함한 전체 URI(FQDN) 지정 필요
            - 이에 따라 동일 IP 주소를 갖는 단일 서버에 여러 사이트가 구축 가능
        - **User-Agent**: 클라이언트 소프트웨어(브라우저, OS) 명칭 및 버전 정보
        - **From**: 클라이언트 사용자 메일 주소
            - 주로 검색엔진 웹 로봇의 연락처 메일 주소를 나타냄
            - 때로는, 이 연락처 메일 주소를 User-Agent 항목에 두는 경우도 있음
        - **Cookie**: 서버에 의해 Set-Cookie로 클라이언트에게 설정된 쿠키 정보
        - **Referer**: 바로 직전에 머물었던 웹 링크 주소
        - **If-Modified-Since**: 제시한 일시 이후로만 변경된 리소스를 취득 요청
        - **Authorization**: 인증 토큰(JWT/Bearer 토큰)을 서버로 보낼 때 사용하는 헤더
            - 토큰의 종류(Basic, Bearer 등) + 실제 토큰 문자를 전송
        - **Origin**
            - 서버로 POST 요청을 보낼 때, 요청이 어느 주소에서 시작되었는지 나타냄
            - 여기서 요청을 보낸 주소와 받는 주소가 다르면 *CORS 에러*가 발생
            - 응답 헤더의 **Access-Control-Allow-Origin**와 관련
    - 다음 4개는 주로 HTTP 메세지 Body의 속성 또는 내용 협상용 항목들
        - **Accept**: 클라이언트 자신이 원하는 미디어 타입 및 우선순위를 알림
            - `Accept: */*` => 어떤 미디어 타입도 가능
            - `Accept: image/*` => 모든 이미지 유형
        - **Accept-Charset**: 클라이언트 자신이 원하는 문자 집합
        - **Accept-Encoding**: 클라이언트 자신이 원하는 문자 인코딩 방식
        - **Accept-Language**: 클라이언트 자신이 원하는 가능한 언어
        - 각각이 HTTP Entity Header 항목 중에 `Content-Type, Content-Type charset-xxx, Content-Encoding, Content-Language`과 일대일로 대응됨

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%2011.png)

- HTTP 헤더 내 응답 헤더 (Response Header) 항목
    - 특정 유형의 HTTP 요청이나 특정 HTTP 헤더를 수신했을 때, 이에 응답한다.
    - 주요 항목들
        - **Server**: 서버 소프트웨어 정보
        - **Accept-Range**
        - **Set-Cookie**: 서버측에서 클라이언트에게 세션 쿠키 정보를 설정 (RFC 2965에서 규정)
        - **Expires**: 리소스가 지정된 일시까지 캐시로써 유효함
        - **Age**: 캐시 응답. max-age 시간 내에서 얼마나 흘렀는지 알려줌(초 단위)
        - **ETag**: HTTP 컨텐츠가 바뀌었는지를 검사할 수 있는 태그
        - **Proxy-authenticate**
        - **Allow**: 해당 엔터티에 대해 서버 측에서 지원 가능한 HTTP 메소드의 리스트를 나타냄
            - 때론, HTTP 요청 메세지의 HTTP 메소드 OPTIONS에 대한 응답용 항목
                - OPTIONS: 웹서버측 제공 HTTP 메소드에 대한 질의
            - `Allow: GET,HEAD` => 웹 서버측이 제공 가능한 HTTP 메서드는 GET,HEAD 뿐임을 알림 (405 Method Not Allowed 에러와 함께)
        - **Access-Control-Allow-Origin**: 요청을 보내는 프론트 주소와 받는 백엔드 주소가 다르면 *CORS 에러*가 발생
            - 서버에서 이 헤더에 프론트 주소를 적어주어야 에러가 나지 않는다.
            - `Access-Control-Allow-Origin: www.zerocho.com`
                - 프로토콜, 서브도메인, 도메인, 포트 중 하나만 달라도 CORS 에러가 난다.
            - `Access-Control-Allow-Origin: *`
                - 만약 주소를 일일이 지정하기 싫다면 *으로 모든 주소에 CORS 요청을 허용되지만 그만큼 보안이 취약해진다.
            - 유사한 헤더로 `Access-Control-Request-Method, Access-Control-Request-Headers, Access-Control-Allow-Methods, Access-Control-Allow-Headers` 등이 있다.

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%2012.png)

[http://www.ktword.co.kr/abbr_view.php?nav=&m_temp1=5905&id=902](http://www.ktword.co.kr/abbr_view.php?nav=&m_temp1=5905&id=902)

[https://gmlwjd9405.github.io/2019/01/28/http-header-types.html](https://gmlwjd9405.github.io/2019/01/28/http-header-types.html)

[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)

# GET과 POST의 차이

### GET

- 주로 조회할 때 사용
- 요청데이터를 URL에 파라미터로 담아서 전송
- URL에 데이터를 포함해서 전달하므로 전송하는 길이에 제한이 있다.
- 정적 컨텐츠를 요청하면 브라우저가 요청을 캐싱해두고 동일 요청이 들어오면 캐싱된 데이터를 전송

### POST

- 서버의 상태나 데이터를 생성할 때 사용된다
- 요청 정보를 Body에 담는다.
- 요청 Body는 길이 제한이 없기 때문에 Get과 달리 대용량 데이터 전송 가능
- 요청 헤더의 Content-Type에 요청 데이터의 타입을 표시해야한다.

# TCP/IP 프로토콜 스택 4계층

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%2013.png)

어떤 통신 관련 하드웨어 기술이든 IP만 구현하면 되고, 어떤 응용 프로그램이든 IP 위에서만 동작하게 하면 된다.

유선 랜(이더넷)과 와이파이 모두 IP 주소를 쓰고 블루투스,LTE, 5G도 통신을 할때는 IP 주소를 부여받아 통신한다. 즉 어떤 통신 방법이든 IP를 구현하는 한, IP 위에서 동작하던 응용 프로그램을 지원하는 데 문제가 없으며 어떤 응용프로그램이든 UP로 통신한다는 것을 전제하면 IP를 지원하는 어떤 하드웨어 기술에서도 동작할 수 있다.

이 덕분에 응용 프로그램과 하드웨어 기술은 독립적으로 발전할 수 있게 되었다. 

IP가 서로 다른 네트워크를 연결하기 때문에 각각의 네트워크는 독립적으로 동작하고 이로 인해 UP는 통신의 안정성을 보장해주지 못한다. 그래서 그 위에 TCP를 깔아 안정성 있는 통신을 제공한다.

어떻게 안정성을 보장해주는가? ACK와 타임아웃, 재전송으로

ACK는 받은 걸 받았다고 알려주는 것을 의미한다. TCP는 패킷을 받을 때마다 ACK라는 별도의 패킷을 만들어서 ‘잘 받았습니다. 제가 다음에 받아야할 것은 몇번 패킷입니다’를 보낸쪽에 알려줌으로써 송신측에서 데이터가 잘 가고 있는지를 판단한다.

ACK가 일정시간동안 오지 않으면 패킷을 보내는 쪽에서는 다시 보낸다. ACK가 오지 않는 경우는 두가지를 생각해 볼 수 있다. 보낸 패킷이 받는 쪽에 도착을 못해서 받는 쪽이 ACK를 보내야 하는 것을 아예 모르는 경우, 받는 쪽이 받았다는 ACK를 보냈는데 ACK가 불안정한 IP떄문에 중간에 배달 사고가 난경우.

어떤 경우든 일정시간동안 ACK를 받지 못하면 패킷을 다시 보내버린다.

### 링크 계층(네트워크 인터페이스 계층)

- 물리적인 영역의 표준화에 대한 결과. LAN, WAN, MAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역
- 물리적 네트워크를 통한 실제 송수신 담당
    - 데이터링크 계층과 물리 계층

### IP(인터넷 계층)

- 경로 검색을 해주는 계층
- IP 자체는 비연결지향적이며 신뢰할 수 없는 프로토콜
- 데이터를 전송할 때마다 거쳐야 할 경로를 선택해주지만 그 경로는 일정하지 않다.
- 특히 데이터 전송 도중에 경로상의 문제가 발생하면 다른 경로를 선택해주는데, 이 과정에서 데이터가 손실되거나 오류가 발생하는 등의 문제가 발생할 수 있고 이를 해결해주진 않는다.
- 즉, 오류 발생에 대한 대비가 되어있지 않은 프로토콜이다.

### TCP/UDP(전송 계층)

- 데이터의 실제 송수신을 담당한다.
- UDP는 TCP에 비해 상대적으로 간단하다.
- TCP는 신뢰성 있는 데이터의 전송을 담당한다.
- TCP가 데이터를 보낼 때 기반이 되는 프로토콜을 IP이다.
- IP 계층은 문제 발생시 해결해주지 않아 신뢰성이 없다.
- 이를 해결해주는 것이 TCP이다.
- 데이터가 순서대로 전송되었는지 확인하며 대화를 주고 받는다.
- 확인절차를 거쳐서 신뢰성 없는 IP에 신뢰성을 부여하는 프로토콜

### Application계층

- 이러한 서버와 클라이언트의 프로그램 성격에 따라 데이터 송수신에 대한 규칙이 정해지는데 이를 가리켜 Application 프로토콜이라고 한다.
- 세션,표현,어플리케이션 계층

[https://www.inven.co.kr/webzine/news/?news=165870](https://www.inven.co.kr/webzine/news/?news=165870)

# 쿠키, 세션

### HTTP의 특징과 쿠키,세션 사용 이유

서버와 클라이언트가 통신을 할 때 마다 서버는 클라이언트가 누구인지 인증을 계속해야한다.

그 이유는 HTTP 프로토콜이 connectionless, stateless한 특성이 있기 때문이다.

### Connectionless

- 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어버리는 특징

### Stateless

- 통신이 끝나면 상태를 유지하지 않는 특징

**쿠키와 세션은 위의 특징을 해결하기 위해, 즉 클라이언트의 인증을 유지하기 위해 사용**

## 쿠키

쿠키란, 클라이언트 측(브라우저)에사 관리되는 작은 **기록 정보 파일**을 의미한다.

쿠키에는 사용자 인증이 유효한 시간을 명시할 수 있으며, 한 번 유효 시간이 정해지면 브라우저를 끄더라도 인증이 유지된다.

### 쿠키 동작 방식

1. 클라이언트가 페이지를 요청
2. 서버에서 쿠키를 생성
3. HTTP 헤더에 쿠키를 포함시켜 응답
4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
5. 쿠키가 존재하면 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보내서 요청
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 경우, 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

### 쿠키 사용 예

- 방문 사이트에서 로그인 시 “아이디와 비밀번호 저장하시겠습니까?”
- 쇼핑물의 장바구니 기능

## 세션

세션은 쿠키를 기반으로 하고 있지만, 사용자 정보 파일을 서버측에서 관리한다.

- 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지한다.
- 접속 시간에 제한을 두어 일정 시간 응답이 없으면 세션을 끊도록 설정 가능
- 사용자에 대한 정보를 서버에 저장하기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 된다.
- 동접자 수가 많은 웹사이트의 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 된다.

### 세션 동작 방식

1. 클라이언트가 서버에 접속 시 세션 ID를 발급
2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장
3. 클라이언트가 서버에 다시 접속 시 이 쿠키를 이용해 세션 ID값을 서버에 전달.

### 세션 특징

- 각 클라이언트에게 고유 ID를 부여
- 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
- 보안 면에서 쿠키보다 우수
- 로그인과 같이 보안상 중요한 작업을 수행할 때 사용한다.

## 쿠키, 세션 차이

**사용자의 기록 정보가 저장되는 위치(쿠키: 클라이언트, 세션:서버)**

쿠키는 서버의 자원을 사용하지 않지만 세션은 서버의 자원을 사용

요청 속도는 쿠키가 세션보다 빠르다. 세션은 서버에서의 처리가 필요하기 때문

[https://victorydntmd.tistory.com/34](https://victorydntmd.tistory.com/34)

# HTTP Keep Alive, TCP Keep Alive

HTTP는 TCP 기반이기 때문에 신뢰성 있는 연결을 한다. 그리고 연결을 유지하지 않는다. 매번 커넥션을 맺고 끊다보니 비용이 발생한다. 그래서 HTTP/1.1 스펙부터 keep-alive 헤더가 추가되어 커넥션을 맺은채로 사용할 수 있다. (connection : keep-alive). 하지만 모든 클라이언트가 1번씩만 호출되는 경우라면 keep-alive 설정된 시간만큼 자원을 유지하고 있어야하므로 더 비효율적이다. 어플리케이션 앞 단에 프록시 서버가 있다면 프록시와 어플리케이션은 당연히 keep-alive 설정을 하는게 이로울 것이다.

### TCP keepalive

- 서버간에 ACK 패킷을 보내 세션 테이블이 지워지지 않고 계속 세션 정보를 유지
- mq, kafka 등 TCP 기반의 서비스들을 대상으로 지속적 연결을 유지해야 하는 경우 사용
- 과정
    - A-B가 서로 Connection이 Establish된 상태에서( 3way-handshake)
    - 지정된 시간(OS 설정 값 똔느 어플리케이션 설정)동안 서로 패킷 교환이 없을경우
    - payload가 없는 패킷을 보낸다.
    - 패킷에 반응 없으면 접속 close
- 한쪽만 연결되어 있는 상태를 정리하기 위해 사용

### HTTP keepalive

- http는 특성상 커넥션을 유지하지 않는다.
- 따라서 keepalive를 사용해 커넥션을 유지해서 빠르게 데이터를 주고 받을 수 있다.
- 일정시간이 지나면 능동적으로 연결을 끊는다.
- 너무 많은 연결을 오래 유지하면 , 다른 연결에 방해를 줄 수 있다.
- Apache, Nginx 등 웹 어플리케이션에서 설정된 기간까지 최대한 연결을 유지하기 위해 사용된다.

**더 공부하기**

# 웹 브라우저에 URL 입력하면?

- 주소 표시줄에 URL을 입력하고 엔터를 입력한다.
- 웹브라우저가 URL을 해석한다.
- HSTS(HTTP 대신 HTTPS만을 사용해서 통신해야 한다고 웹 사이트가 웹 브라우저에게 알리는 보안 기능) 목록을 로드해서 확인한다.
- HSTS 목록에 있으면 첫 요청을 HTTPS로 보내고 아니면 HTTP로 보낸다.
- DNS를 조회한다.
- ARP로 대상 IP와 MAC 주소를 알아낸다.
- 대상과 TCP 통신을 위해 소켓을 연다.
    - 브라우저가 대상 서버의 IP 주소를 받으면 URL에서 해당 포트번호(HTTP의 기본값은 80, HTTPS는 443)를 가져와서 TCP 소켓 스트림 요청
- 3 way 핸드쉐이크를 통해 클라이언트와 서버가 모두 데이터를 전송할 준비가 되었다는 것을 보장
    - 클라이언트가 신을 보내면 서버는 에크와 신을 보내고 클라이언트가 에크를 보낸다.
- HTTPS인 경우 TLS가 추가된다. (TLS는 SSL이 표준화되면서 바뀐 이름이다.)
- TCP 소켓 통신
- HTTP 프로토콜로 요청
- 웹서버가 HTTP 요청을 받아서 정적 리소스는 바로 응답을 해주고 동적 처리가 필요하면 was로 요청을 넘겨서 was에서 처리한 결과를 받아 클라이언트에게 전달
- 응답받아서 웹 브라우저가 그린다.

# 흐름 제어 기법 중 슬라이딩 윈도우 방식

### TCP는 신뢰성을 보장하기 위해 흐름제어, 혼잡제어, 오류제어를 한다.

### 흐름제어

- 수신 측과 송신측의 데이터 처리 속도 차이를 해결하기 위한 기법
- 송신 측과 수신 측의 데이터 처리 속도를 조절해서 수신자의 버퍼 오버플로우를 방지하는 것이다.
- 송신측 전송량>수신측 처리량 일때, 송신측 패킷 전송량을 제어한다.
- 정지-대기, 슬라이딩 윈도우가 있다.

### 정지-대기

- 매번 전송한 패킷에 대해 응답을 받아야만 다음 패킷을 전송할 수 있다.
- 간단한 구조, 비효율적

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%2051a07ef12b994efeb4f55ab5f841764f/Untitled%2014.png)

### 슬라이딩 윈도우

- 전송측이 전송한 프레임에 대한 ACK 프레임을 수신하지 않아도, 여러개의 프레임을 연속적으로 전송하도록 허용하는 방법
- 슬라이딩 윈도우 기법을 통해서 **송신 버퍼의 범위는 수신측의 여유 버퍼 공간을 반영하여 동적으로 바뀜으로써 흐름제어를 수행한다.**

[https://woovictory.github.io/2018/12/28/Network-Erro-Flow-Control/](https://woovictory.github.io/2018/12/28/Network-Erro-Flow-Control/)

[https://wildpup.cafe24.com/archives/469](https://wildpup.cafe24.com/archives/469)

# CORS

# HTTP request, response